<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>1</string>
		<key>identifier</key>
		<string>1</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> None
 </string>
		<key>optionB</key>
		<string> I, II and III
 </string>
		<key>optionC</key>
		<string> I only
 </string>
		<key>optionD</key>
		<string> II and III only 
</string>
		<key>question</key>
		<string>1. Which of the following Visual C++ objects are contained within a "Project"? 
  I.Files 
  II.Visual C++ Solutions 
  III.Flow charts 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>2</string>
		<key>identifier</key>
		<string>2</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> good, because tools from different sources cannot be made to interact with each other
 </string>
		<key>optionB</key>
		<string> good, because it ensures compilation is not done incrementally by accident
 </string>
		<key>optionC</key>
		<string> bad, because all the tools will then have the same user interface
 </string>
		<key>optionD</key>
		<string> bad, because no single vendor is likely to be the source of all the best tools
</string>
		<key>question</key>
		<string>2. Integrated programming environments make it difficult to mix and match tools from different sources. This is  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>3</string>
		<key>identifier</key>
		<string>3</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only
 </string>
		<key>optionB</key>
		<string> II and III only
 </string>
		<key>optionC</key>
		<string> III only
 </string>
		<key>optionD</key>
		<string> I, II, and III. 
</string>
		<key>question</key>
		<string> 3.  When debugging using Visual C++, which of the following are possible through the Watch window? 
   I.The program's execution can be stopped. 
   II.The value of an arbitrary C expression can be calculated. 
   III.The value of a program variable can be set. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>4</string>
		<key>identifier</key>
		<string>4</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> it is often necessary to start the program multiple times under the debugger
 </string>
		<key>optionB</key>
		<string> the program is usually executed to the point at which the behavior occurs and then executed backwards to find the cause
 </string>
		<key>optionC</key>
		<string> it is fastest to start by stopping the debugger long before the behavior appears
 </string>
		<key>optionD</key>
		<string> the faulty code fragment must first be identified  
</string>
		<key>question</key>
		<string> 4. When using a debugger to find the cause of a program's incorrect behavior,  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>5</string>
		<key>identifier</key>
		<string>5</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> nothing: it will not compile because it is ambiguous
 </string>
		<key>optionB</key>
		<string> two integers that are exactly the same
 </string>
		<key>optionC</key>
		<string> two very different integers
 </string>
		<key>optionD</key>
		<string> two values, one 4 greater than the other 
</string>
		<key>question</key>
		<string>5. Consider the following program. 
int i;
int * jp = &amp;i;
int main(int i, char * argv[]) {
    printf("%d %d\n", (int) &amp;i, (int) jp);
}
Which of the following describes what it prints?  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>6</string>
		<key>identifier</key>
		<string>6</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 4
 </string>
		<key>optionB</key>
		<string> It cannot be determined from the information given.
 </string>
		<key>optionC</key>
		<string> 8
 </string>
		<key>optionD</key>
		<string> 5 
</string>
		<key>question</key>
		<string> 6. What is printed as a result of execution of the following program? 
#include &lt;stdio.h&gt;
void callee(int * count) {
    (*count)++;
}
int main (int argc, char *argv[]) {
    int count = 4;
    callee(&amp;count);
    printf("%d", count);
    return 0;
}
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>7</string>
		<key>identifier</key>
		<string>7</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 5
 </string>
		<key>optionB</key>
		<string> nothing: it will not compile successfully
 </string>
		<key>optionC</key>
		<string> 8
 </string>
		<key>optionD</key>
		<string> 4 
</string>
		<key>question</key>
		<string>7.What does the following program print? 
void callee(int * count) {
    (*count)++;
}
int main (int argc, char *argv[]) {
    int count = 4;
    callee(count);
    printf("%d", count);
    return 0;
}
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>8</string>
		<key>identifier</key>
		<string>8</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> plusone and number only.
 </string>
		<key>optionB</key>
		<string> i only.
 </string>
		<key>optionC</key>
		<string> plusone only.
 </string>
		<key>optionD</key>
		<string> i, j and number only. 
</string>
		<key>question</key>
		<string>8 Consider the following program. 
int i;
int j = 1;
int callee(int number) {
    int plusone;
    plusone = number + 1;
    return plusone;
}
int main (int argc, char *argv[]) {
    if (j == 1) return callee(i);
    return j;
}
Which of the following are allocated in the activation record immediately after the function callee() is invoked?  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>9</string>
		<key>identifier</key>
		<string>9</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the contents of memory, interpreted as 32-bit integers, without the associated variable names
 </string>
		<key>optionB</key>
		<string> the names and values of variables in memory, interpreted as 32-bit integers no matter what the variables' types
 </string>
		<key>optionC</key>
		<string> the contents of memory, interpreted in one of several ways, without the associated variable names
 </string>
		<key>optionD</key>
		<string> the names and values of variables in memory, interpreted in one of several ways 
</string>
		<key>question</key>
		<string> 9.  The Visual C++ Memory window displays  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>10</string>
		<key>identifier</key>
		<string>10</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 32
 </string>
		<key>optionB</key>
		<string> 4
 </string>
		<key>optionC</key>
		<string> 0
 </string>
		<key>optionD</key>
		<string> 8  
</string>
		<key>question</key>
		<string> 10. In a computer in which both addresses and integers are 32 bits wide, how many bytes of memory will the compiler allocate for following code fragment? 
int a;
int * b = &amp;a;
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>11</string>
		<key>identifier</key>
		<string>11</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only
 </string>
		<key>optionB</key>
		<string> I only
 </string>
		<key>optionC</key>
		<string> I, II, and III
 </string>
		<key>optionD</key>
		<string> I and III only  
</string>
		<key>question</key>
		<string> 11. Which of the following are true of the effect that optimizations have on the machine code generated by compilers? 
  I.The resulting code will be faster and/or smaller. 
  II.The resulting code will be clearer. 
  III.The resulting code will be harder to debug. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>12</string>
		<key>identifier</key>
		<string>12</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III
 </string>
		<key>optionB</key>
		<string> I only
 </string>
		<key>optionC</key>
		<string> II only
 </string>
		<key>optionD</key>
		<string> I and II only 
</string>
		<key>question</key>
		<string> 12.  Which of the following computations may be performed by exactly one CPU instruction? 
   I.a = 5; 
   II.a = b + c * 5; 
   III.for (i = 0; i &lt; 10; i += a[i++]); 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>13</string>
		<key>identifier</key>
		<string>13</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the memory of a SPARC CPU is numbered from top to bottom
 </string>
		<key>optionB</key>
		<string> the operation codes understood by the two processors are different
 </string>
		<key>optionC</key>
		<string> the assembly mnemonics for the same "opcode" are different in the two processors
 </string>
		<key>optionD</key>
		<string> copyrights regarding code cannot be violated 
</string>
		<key>question</key>
		<string> 13.  Programs compiled for an Intel Pentium processor do not execute properly on a SPARC processor from Sun Microsystems because  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>14</string>
		<key>identifier</key>
		<string>14</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
 </string>
		<key>optionB</key>
		<string> II and III only
 </string>
		<key>optionC</key>
		<string> III only
 </string>
		<key>optionD</key>
		<string> II only 
</string>
		<key>question</key>
		<string> 14.  Consider the following pseudo-instructions. 
     0x40B7D8 i = i - 1
     0x40B7E0 branch-if-not-zero 0x40B7D8
Which of the following code fragments do the instructions encode? 
    I.if (i != 0) i = i -1; 
    II.while (--i); 
    III.do { i = i - 1; } while (i); 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>15</string>
		<key>identifier</key>
		<string>15</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III.
 </string>
		<key>optionB</key>
		<string> I and III only
 </string>
		<key>optionC</key>
		<string> III only
 </string>
		<key>optionD</key>
		<string> II and III only
</string>
		<key>question</key>
		<string> 15.Which of the following does a debugger do? 
    I.Analyze the source code to find programming errors. 
    II.Decode machine code generated by a compiler. 
    III.Stop execution of a program. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>16</string>
		<key>identifier</key>
		<string>16</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> executes more quickly than the source code
 </string>
		<key>optionB</key>
		<string> does not preserve all the information given in the source code
 </string>
		<key>optionC</key>
		<string> associates variable values with their names
 </string>
		<key>optionD</key>
		<string> can be easily inspected to check the correctness of the compiler 
</string>
		<key>question</key>
		<string> 16.The machine code generated from source code by a compiler  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>17</string>
		<key>identifier</key>
		<string>17</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the status window of the Visual C++ environment
 </string>
		<key>optionB</key>
		<string> a program that is able to control the operating system of a windows computer
 </string>
		<key>optionC</key>
		<string> built by using sophisticated "Application Wizards"
 </string>
		<key>optionD</key>
		<string> the simplest type of application Visual C++ can generate 
</string>
		<key>question</key>
		<string>17. In Visual C++, a Win32 Console Application is  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>18</string>
		<key>identifier</key>
		<string>18</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 0
 </string>
		<key>optionB</key>
		<string> 1
 </string>
		<key>optionC</key>
		<string> 4
 </string>
		<key>optionD</key>
		<string> 5  
</string>
		<key>question</key>
		<string>18. Consider the function factorial() defined as follows. 
int factorial(int n) {
    if (n == 1) return n;
    return n * factorial(n - 1);
}
How many activation records of factorial are allocated by invocation of the expression factorial(4)?  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>19</string>
		<key>identifier</key>
		<string>19</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> functions need to access all the variables of the functions that call them.
 </string>
		<key>optionB</key>
		<string> they are seldom needed during program execution.
 </string>
		<key>optionC</key>
		<string> stacks allow activation records to be pushed and popped in any order.
 </string>
		<key>optionD</key>
		<string> stacks are simple enough for the hardware to manag
</string>
		<key>question</key>
		<string>19. Activation records are organized in stacks because  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>20</string>
		<key>identifier</key>
		<string>20</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> just one address, and it is not known to the compiler
 </string>
		<key>optionB</key>
		<string> many addresses none of which is known to the compiler
 </string>
		<key>optionC</key>
		<string> many addresses that were chosen by the compiler
 </string>
		<key>optionD</key>
		<string> just one address, and it was chosen by the compiler
</string>
		<key>question</key>
		<string>20. Consider the following program segment. 
int factorial(int * arg) {
    int n = *arg;
    if (n == 1) return n;
    return n * factorial(n - 1);
}
When the segment is executed, the variable n is allocated to  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>21</string>
		<key>identifier</key>
		<string>21</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 4
 </string>
		<key>optionB</key>
		<string> 0
 </string>
		<key>optionC</key>
		<string> 64
 </string>
		<key>optionD</key>
		<string> 8  
</string>
		<key>question</key>
		<string>21. In a computer in which both addresses and integers are 32 bits wide, how many bytes of memory will the compiler allocate as a result of the following   pointer declaration? 
     int * pointer;  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>22</string>
		<key>identifier</key>
		<string>22</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> When executed, the program will be prematurely terminated by the operating system because of an illegal memory access.
 </string>
		<key>optionB</key>
		<string> Execution will fail because a has the wrong size.
 </string>
		<key>optionC</key>
		<string> i will have the value 99 at the end of any execution of the segment.
 </string>
		<key>optionD</key>
		<string> i will have the value of the last element of the array a at the end of any execution of the segment.  
</string>
		<key>question</key>
		<string>22. Consider the following segment of a C program. 
int i = 99;
int a[100];
i = a[i + 1];
Which of the following is true of the segment?  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>23</string>
		<key>identifier</key>
		<string>23</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> factorial() * factorialfunc;
 </string>
		<key>optionB</key>
		<string> we can't: C cannot extract the addresses of instructions.
 </string>
		<key>optionC</key>
		<string> int (*factorialfunc)(int);
 </string>
		<key>optionD</key>
		<string> int (int) * factorialfunc  
</string>
		<key>question</key>
		<string>23. We want the variable factorialfunc to hold the address of the first instruction of the following function: 
int factorial(int n) {
    if (n == 1) return n;
    return n * factorial(n -1);
}
How would we declare the variable?  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>24</string>
		<key>identifier</key>
		<string>24</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only
 </string>
		<key>optionB</key>
		<string> I and II only
 </string>
		<key>optionC</key>
		<string> I, II, and III
 </string>
		<key>optionD</key>
		<string> I only
</string>
		<key>question</key>
		<string> 24. Suppose that, using a tool such as the memory window of Visual C++, we found that a certain set of contiguous memory locations contained the integer 0xC605CD623A8365000000. What could these memory locations hold? 
     I.the integer 0xC605CD623A8365000000 
     II.a string 
     III.a CPU instruction  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>25</string>
		<key>identifier</key>
		<string>25</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only
 </string>
		<key>optionB</key>
		<string> II and III only
 </string>
		<key>optionC</key>
		<string> III only
 </string>
		<key>optionD</key>
		<string> I, II, and III. 
</string>
		<key>question</key>
		<string> 25.Which of the following does a debugger do? 
Analyze the source code to find programming errors. 
Decode machine code generated by a compiler. 
Stop execution of a program. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>26</string>
		<key>identifier</key>
		<string>26</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only
 </string>
		<key>optionB</key>
		<string> none
 </string>
		<key>optionC</key>
		<string> II and III only
 </string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>26 Consider the following fragment of C++ source code. 
String msg; unsigned int x; int y;
cin &gt;&gt; msg &gt;&gt; x &gt;&gt; y;
cout &lt;&lt; x + y;
Which of the following is (are) true regarding execution of the segment? 
   I.The input statement will always take the same amount of time to execute. 
   II.The output statement will always be executed immediately after the input statement. 
   III.If x and y are both positive, an integer greater than both will be printed. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>27</string>
		<key>identifier</key>
		<string>27</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the program is usually executed to the point at which the behavior occurs and then executed backwards to find the cause
 </string>
		<key>optionB</key>
		<string> the faulty code fragment must first be identified
 </string>
		<key>optionC</key>
		<string> it is fastest to start by stopping the debugger long before the behavior appears
 </string>
		<key>optionD</key>
		<string> it is often necessary to start the program multiple times under the debugger 
</string>
		<key>question</key>
		<string>27.When using a debugger to find the cause of a program's incorrect behavior,  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>28</string>
		<key>identifier</key>
		<string>28</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> many addresses chosen by the compiler.
 </string>
		<key>optionB</key>
		<string> exactly one address chosen by the compiler.
 </string>
		<key>optionC</key>
		<string> exactly one address not known to the compiler.
 </string>
		<key>optionD</key>
		<string> many addresses neither of which are known to the compiler. 
</string>
		<key>question</key>
		<string>28.Consider the following program. 
int square(int * arg) {
    int n = * arg;
    return n * n;
}
int main (int argc, char * argv[]) {
    int arg = strtol(argv[1], NULL, 0);
    return square(arg);
}
When it is executed with the argument 5, the variable n is allocated to  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>29</string>
		<key>identifier</key>
		<string>29</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The value of *d is closer to the value of *c than to the value of *a.
 </string>
		<key>optionB</key>
		<string> The values of *a and *b are closer to each other than the values of *c and *d.
 </string>
		<key>optionC</key>
		<string> The value of &amp;d is closer to the value of &amp;c than to the value of &amp;a.
 </string>
		<key>optionD</key>
		<string> The values of &amp;a and &amp;b are closer to each other than the values of &amp;c and &amp;d.
</string>
		<key>question</key>
		<string>29.  Consider the following code fragment. 
int a;
int b;
int main(int argc, char *argv[]) {
   int c;
   int d;
   ...
   /* some code */
}

Which of the following must be true?  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>3</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>30</string>
		<key>identifier</key>
		<string>30</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only
 </string>
		<key>optionB</key>
		<string> I, II, and III
 </string>
		<key>optionC</key>
		<string> II only
 </string>
		<key>optionD</key>
		<string> II and III only
</string>
		<key>question</key>
		<string>30. Which of the following is a good reason (are good reasons) to equip the CPU with small amounts of fast memory? 
   I.To make the design of the compiler simpler 
   II.To make some CPU instructions smaller 
   III.To make some CPU instructions faster 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>31</string>
		<key>identifier</key>
		<string>31</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> has a value that cannot be determined without further information
 </string>
		<key>optionB</key>
		<string> is incremented to point to the following instruction
 </string>
		<key>optionC</key>
		<string> remains unchanged
 </string>
		<key>optionD</key>
		<string> is incremented by one
</string>
		<key>question</key>
		<string>31.Immediately after the CPU executes an instruction that is neither a branch nor a jump instruction, the program counter  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>32</string>
		<key>identifier</key>
		<string>32</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> sets the program counter to one of two possible values
 </string>
		<key>optionB</key>
		<string> sets the program counter to one of many possible values
 </string>
		<key>optionC</key>
		<string> increases the program counter by a fixed amount
 </string>
		<key>optionD</key>
		<string> unconditionally sets the program counter to its operand 
</string>
		<key>question</key>
		<string>32.A branch instruction  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>33</string>
		<key>identifier</key>
		<string>33</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> may describe the same algorithm
 </string>
		<key>optionB</key>
		<string> describes the actions of the computer, not just of the CPU
 </string>
		<key>optionC</key>
		<string> is the native way to program most computers
 </string>
		<key>optionD</key>
		<string> does not engage any transistors during its execution
</string>
		<key>question</key>
		<string>33.Compared to a sequence of machine code instructions, a fragment of C code  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>34</string>
		<key>identifier</key>
		<string>34</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only
 </string>
		<key>optionB</key>
		<string> III only
 </string>
		<key>optionC</key>
		<string> II only
 </string>
		<key>optionD</key>
		<string> I only 
</string>
		<key>question</key>
		<string>34.When executing a function callee(), which of the following are true regarding the value of the frame pointer? 
    I.It marks the top of the stack frame of the function that invoked callee(). 
    II.It marks the bottom of the stack frame of callee() 
    III.It is the top of the stack. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>35</string>
		<key>identifier</key>
		<string>35</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only
 </string>
		<key>optionB</key>
		<string> I and II only
 </string>
		<key>optionC</key>
		<string> II and III only
 </string>
		<key>optionD</key>
		<string> II only 
</string>
		<key>question</key>
		<string>35.At which of the following times is an activation record created? 
   I.When a program starts executing. 
   II.Every time a function is invoked. 
   III.When a variable is declared. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>36</string>
		<key>identifier</key>
		<string>36</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only
 </string>
		<key>optionB</key>
		<string> I and III only
 </string>
		<key>optionC</key>
		<string> I only
 </string>
		<key>optionD</key>
		<string> III only  
</string>
		<key>question</key>
		<string> 36.In one computer, the bytes with addresses A, A+1, A+2 and A+3 contain the integer 256, and the variable declared with int * a; has the value A. In a different computer, the bytes with addresses B, B+1, B+2 and B+3 also contain the integer 256, and the variable declared with int * b has the value B. Which of the following are necessarily true? 
     I.The contents of A+1 are equal to the contents of B+1. 
     II.The contents of A+1 are equal to the contents of B+2. 
     III.*a == *b  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>37</string>
		<key>identifier</key>
		<string>37</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the address of the CPU instruction that is about to be executed
 </string>
		<key>optionB</key>
		<string> the number of CPU instructions a program has executed so far
 </string>
		<key>optionC</key>
		<string> the amount of memory a program is currently using
 </string>
		<key>optionD</key>
		<string> the number of times a program has been executed 
</string>
		<key>question</key>
		<string>37.The program counter contains  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>38</string>
		<key>identifier</key>
		<string>38</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only
 </string>
		<key>optionB</key>
		<string> I and III only
 </string>
		<key>optionC</key>
		<string> I, II, and III
 </string>
		<key>optionD</key>
		<string> II and III only 
</string>
		<key>question</key>
		<string> 38.Within Visual C++, which of the following will reveal the value of a variable when the program is stopped at a breakpoint? 
    I.Placing the mouse pointer over the variable name in the source file window.
   II.Inserting a printf() in the program. 
   III.Typing the variable name on the "Watch" window. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>39</string>
		<key>identifier</key>
		<string>39</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> is explicitly loaded and unloaded from normal memory by compiler-generated instructions
 </string>
		<key>optionB</key>
		<string> records the results of periodic CPU diagnostics
 </string>
		<key>optionC</key>
		<string> houses a critical variable for the duration of the execution of a program
 </string>
		<key>optionD</key>
		<string> is automatically loaded when a CPU instruction refers to a word of normal memory 
</string>
		<key>question</key>
		<string>39.A CPU register is a word of CPU memory that  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>40</string>
		<key>identifier</key>
		<string>40</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> does not engage any transistors during its execution
</string>
		<key>optionB</key>
		<string> may describe the same algorithm
</string>
		<key>optionC</key>
		<string> describes the actions of the computer, not just of the CPU
</string>
		<key>optionD</key>
		<string> is the native way to program most computers
</string>
		<key>question</key>
		<string>40. Compared to a sequence of machine code instructions, a fragment of C code </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>41</string>
		<key>identifier</key>
		<string>41</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
</string>
		<key>optionB</key>
		<string> I and II only
</string>
		<key>optionC</key>
		<string> I and III only
</string>
		<key>optionD</key>
		<string> none
</string>
		<key>question</key>
		<string>41. Which of the following must be true if a program is stopped at a specific line within the Visual C++ debugger?
   I. There is at least one breakpoint enabled.
   II. There is a breakpoint enabled on that line.
   III. There is a breakpoint enabled on the line preceding that line.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>42</string>
		<key>identifier</key>
		<string>42</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> increases the program counter
</string>
		<key>optionB</key>
		<string> changes the program counter only if its operand is equal to zero
</string>
		<key>optionC</key>
		<string> unconditionally sets the program counter to its operand
</string>
		<key>optionD</key>
		<string> changes a pointer to point to the next element of an array
</string>
		<key>question</key>
		<string>42.  A jump instruction 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>43</string>
		<key>identifier</key>
		<string>43</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> logic Gates
</string>
		<key>optionB</key>
		<string> machine code
</string>
		<key>optionC</key>
		<string> C++ code
</string>
		<key>optionD</key>
		<string> C code
</string>
		<key>question</key>
		<string>43. Which of the following is able to describe a computation at the highest level of abstraction? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>44</string>
		<key>identifier</key>
		<string>44</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> one
</string>
		<key>optionB</key>
		<string> as many as the number of times it is invoked
</string>
		<key>optionC</key>
		<string> as many as the number of return statements within the function
</string>
		<key>optionD</key>
		<string> two, one for each branch
</string>
		<key>question</key>
		<string>44.How many return addresses does a C function have as a program executes? 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>45</string>
		<key>identifier</key>
		<string>45</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> int A = new int[100];
</string>
		<key>optionB</key>
		<string> int *A = new (int) 100;
</string>
		<key>optionC</key>
		<string> int *A = new int[100];
</string>
		<key>optionD</key>
		<string> int &amp;A = new int[100];
</string>
		<key>question</key>
		<string>45. Which of the following statements properly allocates an array of 100 integers? </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>46</string>
		<key>identifier</key>
		<string>46</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only
</string>
		<key>optionB</key>
		<string> I and II only
</string>
		<key>optionC</key>
		<string> II and III only
</string>
		<key>optionD</key>
		<string> I, II, and III
</string>
		<key>question</key>
		<string>46. Valid comments in C++ include which of the following?
   1. /* comment */
   2. / comment
   3. // comment
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>47</string>
		<key>identifier</key>
		<string>47</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> bool
</string>
		<key>optionB</key>
		<string> char
</string>
		<key>optionC</key>
		<string> unsigned int
</string>
		<key>optionD</key>
		<string> byte
</string>
		<key>question</key>
		<string>47.Each of the following is a basic C++ type except 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>48</string>
		<key>identifier</key>
		<string>48</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II
</string>
		<key>optionB</key>
		<string> None
</string>
		<key>optionC</key>
		<string> II only
</string>
		<key>optionD</key>
		<string> I only
</string>
		<key>question</key>
		<string>48. Which of the following statements might be produced by the decomposition of a problem into objects and relationships?
   1. "A is a type of B"
   2. "A B contains a C"
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>49</string>
		<key>identifier</key>
		<string>49</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Characters are read until the end of the file is reached.
</string>
		<key>optionB</key>
		<string> Characters are read until a non-white-space character is read or until the end of the file is reached.
</string>
		<key>optionC</key>
		<string> The number of non-white-space characters is counted.
</string>
		<key>optionD</key>
		<string> Characters are read until a white space is read.
</string>
		<key>question</key>
		<string>49. Suppose inf is an available ifstream and c is an available character. Consider the following code fragment.
    do
        c = inf.get();
    while (!inf.eof() &amp;&amp; isspace(c));
Which of the following accurately describes the effect of executing this fragment?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>50</string>
		<key>identifier</key>
		<string>50</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> stdin, stdout
</string>
		<key>optionB</key>
		<string> keyboard, screen
</string>
		<key>optionC</key>
		<string> input, output
</string>
		<key>optionD</key>
		<string> cin, cout
</string>
		<key>question</key>
		<string>50. In C++, the standard input stream is accessible using the object _____, and the standard output stream is accessible using the object _____.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>51</string>
		<key>identifier</key>
		<string>51</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> compile two methods and prepare them for use by the program segment's source code
</string>
		<key>optionB</key>
		<string> define two macros available for use in the program segment
</string>
		<key>optionC</key>
		<string> define two keywords to aid in debugging the program segment
</string>
		<key>optionD</key>
		<string> include the contents of two files into the program segment's source code
</string>
		<key>question</key>
		<string>51. Consider the following C++ program segment.
    #include &lt;iostream&gt;
    #include &lt;cstdlib&gt;
    using namespace std;
    int main(int argc, char* argv[]) {
        return EXIT_SUCCESS;
    }
The first two lines of this program segment typically direct the preprocessor to
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>52</string>
		<key>identifier</key>
		<string>52</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> a tool that manipulates source files before compilation
</string>
		<key>optionB</key>
		<string> a virtual CPU that can be used to simulate machine-code execution
</string>
		<key>optionC</key>
		<string> a set of APIs provided by several compiler vendors
</string>
		<key>optionD</key>
		<string> a debugging tool common to most visual programming environments
</string>
		<key>question</key>
		<string>52. In C++, the preprocessor is
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>53</string>
		<key>identifier</key>
		<string>53</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> initialize data members of a class properly after space has been allocated
</string>
		<key>optionB</key>
		<string> clean up memory when an instance goes out of scope
</string>
		<key>optionC</key>
		<string> handle assignments between instances of the class
</string>
		<key>optionD</key>
		<string> prevent memory leaks
</string>
		<key>question</key>
		<string>53. The purpose of a constructor is to 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>54</string>
		<key>identifier</key>
		<string>54</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> initialize data members when an instance is first created
</string>
		<key>optionB</key>
		<string> prevent memory leaks
</string>
		<key>optionC</key>
		<string> be used internally in an object's copy constructor
</string>
		<key>optionD</key>
		<string> provide for proper assignment between objects
</string>
		<key>question</key>
		<string>54.The purpose of the assignment operator is to 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>55</string>
		<key>identifier</key>
		<string>55</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 0 &lt; 10
</string>
		<key>optionB</key>
		<string> 0 &lt;= i &amp;&amp; i &lt;= 10
</string>
		<key>optionC</key>
		<string> 0 &lt;= i &lt; 10
</string>
		<key>optionD</key>
		<string> 0 &lt;= i &amp;&amp; i &lt; 10
</string>
		<key>question</key>
		<string>55. Which of the following expressions evaluates to true in C++ if and only if the index variable i is in bounds for an array of size 10? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>56</string>
		<key>identifier</key>
		<string>56</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> preprocessing, object file
</string>
		<key>optionB</key>
		<string> compiling, preprocessed file
</string>
		<key>optionC</key>
		<string> linking, executable image
</string>
		<key>optionD</key>
		<string> linking, source file
</string>
		<key>question</key>
		<string>56.At the end of the _____ stage for a C++ program, a(n) _____ can be produced.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>57</string>
		<key>identifier</key>
		<string>57</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Simplifying the problem by eliminating low-priority requirements
</string>
		<key>optionB</key>
		<string> Reverse-engineering an algorithm that solves a different problem
</string>
		<key>optionC</key>
		<string> Identifying entities and relationships that will aid in solving the problem
</string>
		<key>optionD</key>
		<string> Determining a programming language for implementing a solution to the problem
</string>
		<key>question</key>
		<string>57. Decomposition of a problem involves which of the following?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>58</string>
		<key>identifier</key>
		<string>58</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> provide a comment for the user
</string>
		<key>optionB</key>
		<string> terminate execution and send an error message whenever the condition is violated
</string>
		<key>optionC</key>
		<string> send a warning message but continue execution when the condition is violated
</string>
		<key>optionD</key>
		<string> instruct the compiler to set i to any value in the indicated range
</string>
		<key>question</key>
		<string>58. One reason for using an assert statement such as

          assert( 0 &lt;= i &amp;&amp; i &lt; 10 );

within code is to
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>59</string>
		<key>identifier</key>
		<string>59</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> #include
</string>
		<key>optionB</key>
		<string> #pragma
</string>
		<key>optionC</key>
		<string> #ifndef
</string>
		<key>optionD</key>
		<string> #define
</string>
		<key>question</key>
		<string>59.Which of the following is the C++ preprocessor directive for file inclusion?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>60</string>
		<key>identifier</key>
		<string>60</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> linker
</string>
		<key>optionB</key>
		<string> preprocessor
</string>
		<key>optionC</key>
		<string> Standard Template Library
</string>
		<key>optionD</key>
		<string> compiler
</string>
		<key>question</key>
		<string>60. In C++, the directive #include is processed by the
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>61</string>
		<key>identifier</key>
		<string>61</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The default constructor
</string>
		<key>optionB</key>
		<string> The copy constructor
</string>
		<key>optionC</key>
		<string> The assignment operator
</string>
		<key>optionD</key>
		<string> The destructor
</string>
		<key>question</key>
		<string>61.Assume that Thing is a user-defined class, and consider the following code fragment, where B is an instance of Thing.
          Thing  A = B;

Which of the following is a class member that is used in this code fragment?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>62</string>
		<key>identifier</key>
		<string>62</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Pointers or references are used with virtual functions.
</string>
		<key>optionB</key>
		<string> Only instances of the base class are used.
</string>
		<key>optionC</key>
		<string> Templates are avoided.
</string>
		<key>optionD</key>
		<string> Only instances of the derived class are used
</string>
		<key>question</key>
		<string>62. Which of the following is necessary in order to obtain polymorphic behavior in C++? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>63</string>
		<key>identifier</key>
		<string>63</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Always
</string>
		<key>optionB</key>
		<string> If and only if the class is not a template class
</string>
		<key>optionC</key>
		<string> If and only if the function is explicitly declared to be virtual
</string>
		<key>optionD</key>
		<string> If and only if the class uses private inheritance
</string>
		<key>question</key>
		<string>63.	Under what circumstances will a member function in C++ display polymorphic behavior? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>64</string>
		<key>identifier</key>
		<string>64</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> D.y = 555;
</string>
		<key>optionB</key>
		<string> D.x = 555;
</string>
		<key>optionC</key>
		<string> D.z = 555;
</string>
		<key>optionD</key>
		<string> None
</string>
		<key>question</key>
		<string>64. Consider the following inheritance declarations.
          class Base    { public: int x; private: int y; };
          class Derived: public Base  { public: int z; };
          Derived  D;
Under these declarations, which of the following statements, if any, will fail to compile?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>65</string>
		<key>identifier</key>
		<string>65</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> it greatly increases efficiency
</string>
		<key>optionB</key>
		<string> it can often replace templates
</string>
		<key>optionC</key>
		<string> it is a powerful code reuse mechanism
</string>
		<key>optionD</key>
		<string> it makes type-checking much easier
</string>
		<key>question</key>
		<string>65,. Inheritance is an important feature of C++ because 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>66</string>
		<key>identifier</key>
		<string>66</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> "catch "
</string>
		<key>optionB</key>
		<string> "try catch "
</string>
		<key>optionC</key>
		<string> "catch try "
</string>
		<key>optionD</key>
		<string> "out of range catch "
</string>
		<key>question</key>
		<string>66. Consider the following C++ program segment:
    try {
        throw out_of_range("out of range");
        cout &lt;&lt; "try ";
    }
    catch (...) {
        cout &lt;&lt; "catch ";
    }
The above program segment will output which of the following character strings?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>67</string>
		<key>identifier</key>
		<string>67</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> underflow_error
</string>
		<key>optionB</key>
		<string> bad_cast
</string>
		<key>optionC</key>
		<string> bad_alloc
</string>
		<key>optionD</key>
		<string> length_error
</string>
		<key>question</key>
		<string>67. In the C++ standard exception hierarchy, which of the following classes is derived from class logic_error?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>68</string>
		<key>identifier</key>
		<string>68</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only
</string>
		<key>optionB</key>
		<string> III only
</string>
		<key>optionC</key>
		<string> None
</string>
		<key>optionD</key>
		<string> I only
</string>
		<key>question</key>
		<string>68. Consider the following outline of a template array class.
          template&lt;class T&gt;  class Array { ... }
Which of the following declarations are in error with respect to using such a class?
   1. Array&lt;Array&lt;int&gt; &gt; A;
   2. Array&lt;Array&lt;int&gt;*&gt; A;
   3. Array&lt;int**&gt; A;
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>69</string>
		<key>identifier</key>
		<string>69</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> a class definition that defines a subtype of the template classes A and B.
</string>
		<key>optionB</key>
		<string> the definition of a class called A that uses the generic type parameter B.
</string>
		<key>optionC</key>
		<string> a class definition containing the generic type parameters A and B.
</string>
		<key>optionD</key>
		<string> definitions of a class called A and a class called B.
</string>
		<key>question</key>
		<string>69. Consider the following partial C++ templated class definition.
    template&lt;class A, class B&gt;
    class ...
The line of code template&lt;class A, class B&gt; will generally be followed by 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>70</string>
		<key>identifier</key>
		<string>70</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
</string>
		<key>optionB</key>
		<string> I and II
</string>
		<key>optionC</key>
		<string> II only
</string>
		<key>optionD</key>
		<string> None
</string>
		<key>question</key>
		<string>70. Which of the following is (are) true about template classes in C++?
   I. Methods cannot be overloaded in templated class definitions.
   II. Private data of a templated class cannot be declared to have the type of the templated parameter. 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>71</string>
		<key>identifier</key>
		<string>71</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III
</string>
		<key>optionB</key>
		<string> II and III
</string>
		<key>optionC</key>
		<string> I and II
</string>
		<key>optionD</key>
		<string> I only
</string>
		<key>question</key>
		<string>71. Consider the following template swap function and data types.
          template&lt;class T&gt;  void  swap( T&amp; a, T&amp; b ){
              T tmp = a; a = b; b = tmp;
          }
          char   c1, c2;
          int    i1, i2;
          float  A[10];
Which of the following calls to swap produces a compile time error?
   I. swap( i1, c2 )
   II. swap( c1, i2 );
   III. swap( A[5], A[2] );
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>72</string>
		<key>identifier</key>
		<string>72</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> polymorphism
</string>
		<key>optionB</key>
		<string> static binding
</string>
		<key>optionC</key>
		<string> inheritance
</string>
		<key>optionD</key>
		<string> composition
</string>
		<key>question</key>
		<string>72. In C++, the ability for an entity to assume different types is known as
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>73</string>
		<key>identifier</key>
		<string>73</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> virtual int Compute() { return 0; };
</string>
		<key>optionB</key>
		<string> virtual int Compute();
</string>
		<key>optionC</key>
		<string> virtual int Compute() = 0;
</string>
		<key>optionD</key>
		<string> int Compute() { Compute = 0; };
</string>
		<key>question</key>
		<string>73.Which of the following is an example of a pure virtual function?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>74</string>
		<key>identifier</key>
		<string>74</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It is an important idea in Object Oriented Programming, but currently it is not implemented in C++.
</string>
		<key>optionB</key>
		<string> It is the inclusion of one class in another as a data member.
</string>
		<key>optionC</key>
		<string> It is the same as polymorphism.
</string>
		<key>optionD</key>
		<string> It is a method to build new classes on top of existing ones.
</string>
		<key>question</key>
		<string>74.What is composition? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>75</string>
		<key>identifier</key>
		<string>75</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> "what"
</string>
		<key>optionB</key>
		<string> "runtime error"
</string>
		<key>optionC</key>
		<string> "exception encountered"
</string>
		<key>optionD</key>
		<string> "out of range"
</string>
		<key>question</key>
		<string>75. Consider the following C++ program segment:
    try {
        throw out_of_range("out of range");
    }
    catch (runtime_error&amp; e) {
        cout &lt;&lt; e.what();
       }
    catch (...) {
        cout &lt;&lt; "exception encountered";
    }
The above program segment will output which of the following character strings?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>76</string>
		<key>identifier</key>
		<string>76</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> throw user-defined exception classes
</string>
		<key>optionB</key>
		<string> override the guarantees of exception specifications
</string>
		<key>optionC</key>
		<string> catch exceptions polymorphically
</string>
		<key>optionD</key>
		<string> ensure allocated resources are properly released
</string>
		<key>question</key>
		<string>76. In C++ exception handling, intermediate exception handlers typically are used to:
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>77</string>
		<key>identifier</key>
		<string>77</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> more, and equally
</string>
		<key>optionB</key>
		<string> more, but less
</string>
		<key>optionC</key>
		<string> less, but less
</string>
		<key>optionD</key>
		<string> less, and equally
</string>
		<key>question</key>
		<string>77. Consider the following definitions of a C++ class.
    class Array  {
       public:
         typedef  float  Item;     // &lt;-- change here
         Item&amp; operator[](int  i)  {return  arr[i];}
       private:
         int    len;   // length of array
         Item  *arr;   // pointer to first elm
    };
    template&lt;class  T&gt;
    class Array  {
         public:
              T&amp; operator[](int  i)  {return  arr[i];}
         private:
              int  len;             T   *arr;   };
The second definition of class Array is _____ versatile than the first _____ efficient at run time when used in a program.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>78</string>
		<key>identifier</key>
		<string>78</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> only user-defined classes
</string>
		<key>optionB</key>
		<string> all types
</string>
		<key>optionC</key>
		<string> only built-in types
</string>
		<key>optionD</key>
		<string> classes as well as structs
</string>
		<key>question</key>
		<string>78. In a template definition
          template&lt;class T&gt;  ...
the template parameter T ranges over
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>79</string>
		<key>identifier</key>
		<string>79</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Template classes cannot be defined for user-defined types, but template functions can.
</string>
		<key>optionB</key>
		<string> Template functions cannot be defined for user-defined types, but template classes can.
</string>
		<key>optionC</key>
		<string> The compiler generates a separate definition for each template function at compile time, but template classes for different types are created at run time.
</string>
		<key>optionD</key>
		<string> The compiler determines the types of a template function's arguments, but the types of template classes must be stated explicitly when declaring objects.
</string>
		<key>question</key>
		<string>79. Which of the following describes a difference between template functions and template classes in C++?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>80</string>
		<key>identifier</key>
		<string>80</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> copy( I, F, 10 );
</string>
		<key>optionB</key>
		<string> copy( C, CC, 10 );
</string>
		<key>optionC</key>
		<string> copy( I, I, 10 );
</string>
		<key>optionD</key>
		<string> copy( I, (int*)F, 10 );
</string>
		<key>question</key>
		<string>80. Consider the following template array-copy function and arrays.
          template&lt;class T&gt;  void  copy( T a[], T b[], int n ) {
              for(int i = 0; i &lt; n; i++ ) a[i] = b[i];
          }
          char   C[10], CC[10];
          int    I[10];
          float  F[10];
Which of the following calls to copy would produce a compile time error?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>81</string>
		<key>identifier</key>
		<string>81</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> If and only if the class is not a template class
</string>
		<key>optionB</key>
		<string> If and only if the function is explicitly declared to be virtual
</string>
		<key>optionC</key>
		<string> If and only if the class uses private inheritance
</string>
		<key>optionD</key>
		<string> Always
</string>
		<key>question</key>
		<string>81.Under what circumstances will a member function in C++ display polymorphic behavior? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>82</string>
		<key>identifier</key>
		<string>82</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 12
 </string>
		<key>optionB</key>
		<string> 48
 </string>
		<key>optionC</key>
		<string> 52
 </string>
		<key>optionD</key>
		<string> 44  
</string>
		<key>question</key>
		<string>82. In C, assuming that an int takes 4 bytes, how many bytes are required to represent the following array? 
  int a[12];  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>83</string>
		<key>identifier</key>
		<string>83</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 5
 </string>
		<key>optionB</key>
		<string> 4
 </string>
		<key>optionC</key>
		<string> 20
 </string>
		<key>optionD</key>
		<string> 16 
</string>
		<key>question</key>
		<string>83.  How many bytes are allocated by the following C declaration and initialization? 
char s[] = "quiz";  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>84</string>
		<key>identifier</key>
		<string>84</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 5
 </string>
		<key>optionB</key>
		<string> 1005
 </string>
		<key>optionC</key>
		<string> 20
 </string>
		<key>optionD</key>
		<string> 1020
</string>
		<key>question</key>
		<string>84. Assume that array a is at location 1000 (decimal). Execution of the following program results in what being printed? 
int a[12];
main() {
    int i;
    for (i = 0; i &lt; 12; i++) a[i] = i;
    printf("%d\n", *(a + 5));
} 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>85</string>
		<key>identifier</key>
		<string>85</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> bit
 </string>
		<key>optionB</key>
		<string> page
 </string>
		<key>optionC</key>
		<string> byte
 </string>
		<key>optionD</key>
		<string> word 
</string>
		<key>question</key>
		<string>85.  In modern computers, each address represents one _____ of memory.  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>86</string>
		<key>identifier</key>
		<string>86</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> to indicate where the decimal or binary point should be
 </string>
		<key>optionB</key>
		<string> the mantissa is raised to the power of the exponent
 </string>
		<key>optionC</key>
		<string> to specify the base as binary, octal, or hexadecimal
 </string>
		<key>optionD</key>
		<string> to specify the superscript  
</string>
		<key>question</key>
		<string>86. What is the purpose of the exponent in floating point numbers?  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>87</string>
		<key>identifier</key>
		<string>87</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 0x5434
 </string>
		<key>optionB</key>
		<string> 0x1030
 </string>
		<key>optionC</key>
		<string> 0x5636
 </string>
		<key>optionD</key>
		<string> 0x4606  
</string>
		<key>question</key>
		<string>87. What is the value of the following C expression? 
       0x1234 ^ 0x5432  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>88</string>
		<key>identifier</key>
		<string>88</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 0x5D
 </string>
		<key>optionB</key>
		<string> 0xAB
 </string>
		<key>optionC</key>
		<string> 0xB5
 </string>
		<key>optionD</key>
		<string> 0xD5
</string>
		<key>question</key>
		<string>88.  In C, what is the following binary number in hexadecimal? 
      11010101  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>89</string>
		<key>identifier</key>
		<string>89</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only
 </string>
		<key>optionB</key>
		<string> II and III only
 </string>
		<key>optionC</key>
		<string> I, II, and III
 </string>
		<key>optionD</key>
		<string> I only  
</string>
		<key>question</key>
		<string>89.Which of the following statements about alignment within C struct's is true? 
   I.Alignment may cause the allocation of unused space. 
   II.Alignment is required by all modern processors. 
   III.Alignment can help processors access data more efficiently. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>90</string>
		<key>identifier</key>
		<string>90</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> to avoid overflow
 </string>
		<key>optionB</key>
		<string> to avoid underflow
 </string>
		<key>optionC</key>
		<string> to align bit positions, simplifying addition
 </string>
		<key>optionD</key>
		<string> to retain as much precision as possible
</string>
		<key>question</key>
		<string>90. Why is the mantissa of a floating point number shifted left as far as possible?  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>91</string>
		<key>identifier</key>
		<string>91</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 0x0092
 </string>
		<key>optionB</key>
		<string> 0x0000
 </string>
		<key>optionC</key>
		<string> 0x0091
 </string>
		<key>optionD</key>
		<string> 0x00A3
</string>
		<key>question</key>
		<string>91.  What is the value of the following C expression? 
0x1234 &gt;&gt; 5  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>92</string>
		<key>identifier</key>
		<string>92</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 12
 </string>
		<key>optionB</key>
		<string> 14
 </string>
		<key>optionC</key>
		<string> 11
 </string>
		<key>optionD</key>
		<string> 13  
</string>
		<key>question</key>
		<string>92. Given the following declarations, h[] takes 7 bytes and t[] takes 6 bytes. What is the minimum amount of memory (in bytes) required to store the concatenation of h and t? 
char h[] = "hello ";
char t[] = "there";
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>93</string>
		<key>identifier</key>
		<string>93</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only
 </string>
		<key>optionB</key>
		<string> I only
 </string>
		<key>optionC</key>
		<string> I and III only
 </string>
		<key>optionD</key>
		<string> II only  
</string>
		<key>question</key>
		<string>93. In a computer with 4-byte words, which of the following C expressions tests whether ptr contains the address of a word? 
    I.(ptr &amp; 3) == 0 
    II.(ptr | 3) == 0 
    III.(ptr % 4) == 0 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>94</string>
		<key>identifier</key>
		<string>94</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> A special value "infinity" is computed, testable with _finite().
 </string>
		<key>optionB</key>
		<string> An exception is raised unless disabled by calling _controlfp().
 </string>
		<key>optionC</key>
		<string> An erroneous value is computed and execution continues.
 </string>
		<key>optionD</key>
		<string> Program execution is halted.  
</string>
		<key>question</key>
		<string>94. In C, using default floating point settings, what happens when a floating-point computation results in an overflow?  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>95</string>
		<key>identifier</key>
		<string>95</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 0x1234000
 </string>
		<key>optionB</key>
		<string> 0x9340
 </string>
		<key>optionC</key>
		<string> 0x91A0
 </string>
		<key>optionD</key>
		<string> 0x48CE  
</string>
		<key>question</key>
		<string>95.What is the value of the following C expression? 
     0x1234 &lt;&lt; 3  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>96</string>
		<key>identifier</key>
		<string>96</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Advances the iterator to the next item.
</string>
		<key>optionB</key>
		<string> Post-increments the item to which the iterator points.
</string>
		<key>optionC</key>
		<string> Increase by 1 the size of the container pointed to by it.
</string>
		<key>optionD</key>
		<string> Pre-increments the item to which the iterator points.
</string>
		<key>question</key>
		<string>96.For an STL iterator it, execution of the statement
        ++it;
does which of the following?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>97</string>
		<key>identifier</key>
		<string>97</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Stack
</string>
		<key>optionB</key>
		<string> List
</string>
		<key>optionC</key>
		<string> Vector
</string>
		<key>optionD</key>
		<string> Hash table
</string>
		<key>question</key>
		<string>97.Which of the following data structures is not a container implemented in the C++ Standard Template Library?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>98</string>
		<key>identifier</key>
		<string>98</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> pointers
</string>
		<key>optionB</key>
		<string> virtual functions
</string>
		<key>optionC</key>
		<string> arrays
</string>
		<key>optionD</key>
		<string> iterators
</string>
		<key>question</key>
		<string>98.In the STL, common algorithms are instantiated for multiple types of container classes by using _____ to provide a uniform interface between the algorithms and containers.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>99</string>
		<key>identifier</key>
		<string>99</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only
</string>
		<key>optionB</key>
		<string> I only
</string>
		<key>optionC</key>
		<string> I and III only
</string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>99.In the C++ Standard Template Library, vectors and deques differ in their interfaces for handling which of the following operations?
   I. Insertion of an element at the front of the container
   II. Insertion of an element at the end of the container
   III. Removal of an element from the front of the container
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>100</string>
		<key>identifier</key>
		<string>100</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> bool is_odd(int begin, int end);
</string>
		<key>optionB</key>
		<string> int is_odd(bool i);
</string>
		<key>optionC</key>
		<string> bool is_odd(int i);
</string>
		<key>optionD</key>
		<string> int is_odd(int begin, int end);
</string>
		<key>question</key>
		<string>100.Consider the following program fragment that calls the method count_if in the C++ Standard Template Library.
       deque&lt;int&gt; numbers;
       ...
       count_if(numbers.begin(), numbers.end(), is_odd);
Which of the following declarations for the method is_odd is correct for the call to count_if?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>101</string>
		<key>identifier</key>
		<string>101</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 0
</string>
		<key>optionB</key>
		<string> 1
</string>
		<key>optionC</key>
		<string> 5000
</string>
		<key>optionD</key>
		<string> 10
</string>
		<key>question</key>
		<string>101.Consider the following program segment.
    vector&lt;int&gt;  A(10);
    A.resize(0);
    A.push_back(5000);
At the end of an execution of this fragment, the size of vector A is
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>102</string>
		<key>identifier</key>
		<string>102</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> An array of 20 arrays of ints, each of size 10
</string>
		<key>optionB</key>
		<string> An array of 10 arrays of ints, each of size 20
</string>
		<key>optionC</key>
		<string> An array of 10 ints, each initialized to 20
</string>
		<key>optionD</key>
		<string> An array of ints, indexed from 10 to 20
</string>
		<key>question</key>
		<string>102.Consider the execution of the following.
          vector&lt;int&gt;  A(10,20);
Which of the following accurately describes what is created?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>103</string>
		<key>identifier</key>
		<string>103</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> total of the sizes of the data members in the vector class
</string>
		<key>optionB</key>
		<string> maximum number of elements that can be stored in the vector without resizing
</string>
		<key>optionC</key>
		<string> number of bytes the vector occupies in memory
</string>
		<key>optionD</key>
		<string> number of elements currently stored in the vector
</string>
		<key>question</key>
		<string>103.The size of an STL vector is defined to be the 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>104</string>
		<key>identifier</key>
		<string>104</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
</string>
		<key>optionB</key>
		<string> I and II
</string>
		<key>optionC</key>
		<string> None
</string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>104.Which of the following statements is (are) true regarding C-style strings?
   I. They are terminated by the null character.
   II. Storing a five-character string requires at least seven characters.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>105</string>
		<key>identifier</key>
		<string>105</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> string s3("Hello, World");
</string>
		<key>optionB</key>
		<string> bool ans = (s2 == "hello");
</string>
		<key>optionC</key>
		<string> bool ans = (s1 == s2);
</string>
		<key>optionD</key>
		<string> bool ans = ("hello" == s1);
</string>
		<key>question</key>
		<string>105.Consider the following C++ program fragment, which is a partial declaration of the class string.
       class string {
         public:
             string(const char* cstring = "");
             bool operator== (const string &amp; rhs);
          ...
       };
Given this class and two string objects called s1 and s2, which of the following is not a legal statement?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>106</string>
		<key>identifier</key>
		<string>106</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Pre-decrements the item to which the iterator points.
</string>
		<key>optionB</key>
		<string> Decreases by 1 the size of the container pointed to by it.
</string>
		<key>optionC</key>
		<string> Steps the iterator backwards to the previous item.
</string>
		<key>optionD</key>
		<string> Post-decrements the item to which the iterator points.
</string>
		<key>question</key>
		<string>106.For an STL iterator it, execution of the statement
   it--;
does which of the following?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>107</string>
		<key>identifier</key>
		<string>107</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only
</string>
		<key>optionB</key>
		<string> I, II, and III
</string>
		<key>optionC</key>
		<string> I only
</string>
		<key>optionD</key>
		<string> III only
</string>
		<key>question</key>
		<string>107.The STL deque container contains which of the following methods?
   I. push_back
   II. push_front
   III. pop_front
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>108</string>
		<key>identifier</key>
		<string>108</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> range, domain
</string>
		<key>optionB</key>
		<string> domain, range
</string>
		<key>optionC</key>
		<string> size, capacity
</string>
		<key>optionD</key>
		<string> capacity, size
</string>
		<key>question</key>
		<string>108.In STL vectors, _____ refers to the maximum number of items that can be stored without resizing, and _____ refers to the number of items stored.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>109</string>
		<key>identifier</key>
		<string>109</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> a copy constructor
</string>
		<key>optionB</key>
		<string> an assignment operator
</string>
		<key>optionC</key>
		<string> a default constructor
</string>
		<key>optionD</key>
		<string> a destructor
</string>
		<key>question</key>
		<string>109.Consider the following declaration that makes use of a user-defined class Thing.
          vector&lt;Thing&gt;  A(10);
In order that it compile, the class Thing must have which of the following?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>110</string>
		<key>identifier</key>
		<string>110</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> a '\n'
</string>
		<key>optionB</key>
		<string> any white-space
</string>
		<key>optionC</key>
		<string> a '0'
</string>
		<key>optionD</key>
		<string> a '\0'
</string>
		<key>question</key>
		<string>110.A C-style string is stored as an array of characters that ends with _____ character.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>111</string>
		<key>identifier</key>
		<string>111</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only
</string>
		<key>optionB</key>
		<string> I and II only
</string>
		<key>optionC</key>
		<string> III only
</string>
		<key>optionD</key>
		<string> I only
</string>
		<key>question</key>
		<string>111.The main abstractions of the Standard Template Library include which of the following?
   I. Iterators
   II. Exception handlers
   III. Algorithms
	</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>112</string>
		<key>identifier</key>
		<string>112</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
</string>
		<key>optionB</key>
		<string> II only
</string>
		<key>optionC</key>
		<string> I and II
</string>
		<key>optionD</key>
		<string> None
</string>
		<key>question</key>
		<string>112.Which of the following statements is (are) true regarding strings in C++?
   I. Strings in C++ are supported by the standard class string.
   II. A constructor for the class string can accept a C-style string as an argument.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>113</string>
		<key>identifier</key>
		<string>113</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> begin( A, it );
</string>
		<key>optionB</key>
		<string> it = A.begin();
</string>
		<key>optionC</key>
		<string> A.reset( it );
</string>
		<key>optionD</key>
		<string> A.begin( it );
</string>
		<key>question</key>
		<string>113.Execution of which of the following statements sets an STL iterator it so that it points to the first element of a container A? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>114</string>
		<key>identifier</key>
		<string>114</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Pre-increments the item to which the iterator points.
</string>
		<key>optionB</key>
		<string> Post-increments the item to which the iterator points.
</string>
		<key>optionC</key>
		<string> Increase by 1 the size of the container pointed to by it.
</string>
		<key>optionD</key>
		<string> Advances the iterator to the next item.
</string>
		<key>question</key>
		<string>114.For an STL iterator it, execution of the statement
        ++it;
does which of the following?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>115</string>
		<key>identifier</key>
		<string>115</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> check array bounds, enlarge the vector if necessary, and then write x to position i
</string>
		<key>optionB</key>
		<string> write x to position i of the vector, without bounds checking
</string>
		<key>optionC</key>
		<string> check array bounds, and write x to position i if and only if i is in the proper range
</string>
		<key>optionD</key>
		<string> create an iterator x pointing to position i in the array
</string>
		<key>question</key>
		<string>115.If A is an STL vector, then the effect of executing the statement
          A[i] = x;
is to
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>116</string>
		<key>identifier</key>
		<string>116</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> inheritance
</string>
		<key>optionB</key>
		<string> templates
</string>
		<key>optionC</key>
		<string> object oriented programming
</string>
		<key>optionD</key>
		<string> polymorphism
</string>
		<key>question</key>
		<string>116.	The STL is heavily based on 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>117</string>
		<key>identifier</key>
		<string>117</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> char &amp;
</string>
		<key>optionB</key>
		<string> char
</string>
		<key>optionC</key>
		<string> char *
</string>
		<key>optionD</key>
		<string> const char &amp;
</string>
		<key>question</key>
		<string>117.Consider the following C++ program segment, assuming that string is a class.
       string str1("Hello, World");
       str1[5] = 'Z';
The overloaded operator[] function invoked in the above program segment should have which of the following return types?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>118</string>
		<key>identifier</key>
		<string>118</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> inserting the element at the next available position in the deque and maintaining a table of element positions
</string>
		<key>optionB</key>
		<string> inserting the element at the end of the deque and maintaining a table of element positions
</string>
		<key>optionC</key>
		<string> using a background thread to reallocate memory when necessary
</string>
		<key>optionD</key>
		<string> reserving memory at the front of the deque's stored elements
</string>
		<key>question</key>
		<string>118.A typical implementation of a deque in the C++ STL minimizes the need to copy elements upon the frontal insertion of new items by
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>119</string>
		<key>identifier</key>
		<string>119</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only
</string>
		<key>optionB</key>
		<string> I only
</string>
		<key>optionC</key>
		<string> None
</string>
		<key>optionD</key>
		<string> I and II
</string>
		<key>question</key>
		<string>119.Which of the following statements is (are) true of typical implementations of vectors and deques?
    I. A vector's implementation uses one array, whereas a deque's implementation uses multiple arrays.
   II. Insertions at the front of a deque tend to be more efficient than insertions at the front of a vector.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>120</string>
		<key>identifier</key>
		<string>120</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> A stack of integers
</string>
		<key>optionB</key>
		<string> A vector of integers
</string>
		<key>optionC</key>
		<string> A vector of integer stacks
</string>
		<key>optionD</key>
		<string> A stack of integer vectors
</string>
		<key>question</key>
		<string>120.Consider the following C++ program segment, which uses the STL.   	
    stack&lt;int,vector&lt;int&gt; &gt; S;
Execution of the statement results in creation of which of the following?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>121</string>
		<key>identifier</key>
		<string>121</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> a sequence container, an adapter class
</string>
		<key>optionB</key>
		<string> an adapter, a C-style array
</string>
		<key>optionC</key>
		<string> an adapter, a sequence container
</string>
		<key>optionD</key>
		<string> a sequence container, a C-style array
</string>
		<key>question</key>
		<string>121.In the C++ Standard Template Library (STL), the class queue is _____ that uses _____ for storage.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>122</string>
		<key>identifier</key>
		<string>122</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only
</string>
		<key>optionB</key>
		<string> I, II, and III
</string>
		<key>optionC</key>
		<string> I and III only
</string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>122.Which of the following statements is (are) true about stacks?
   I. Elements are inserted and deleted in last-in-first-out order.
   II. Stacks can be implemented using linked lists.
   III. Stacks can be implemented using arrays.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>123</string>
		<key>identifier</key>
		<string>123</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> top
</string>
		<key>optionB</key>
		<string> empty
</string>
		<key>optionC</key>
		<string> pop
</string>
		<key>optionD</key>
		<string> push
</string>
		<key>question</key>
		<string>123.Which of the following operations typically removes an item from a stack?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>124</string>
		<key>identifier</key>
		<string>124</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Accessing an item from the front of the queue
</string>
		<key>optionB</key>
		<string> Inserting an item at the back of the queue
</string>
		<key>optionC</key>
		<string> Inserting an item into the second position of the queue
</string>
		<key>optionD</key>
		<string> Removing an item from the front of the queue
</string>
		<key>question</key>
		<string>124.Which of the following is not a basic operation that can be performed on a queue?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>125</string>
		<key>identifier</key>
		<string>125</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Const iterators can be incremented, but never decremented.
</string>
		<key>optionB</key>
		<string> They provide read-only access to a linked list.
</string>
		<key>optionC</key>
		<string> They provide write-only access to a linked list.
</string>
		<key>optionD</key>
		<string> They cannot be used to traverse a linked list.
</string>
		<key>question</key>
		<string>125.In the C++ standard template library (STL), which of the following is a property of const iterators for the list container?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>126</string>
		<key>identifier</key>
		<string>126</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> an attempt is made to access a non-existing list element
</string>
		<key>optionB</key>
		<string> there is no decrement operation for list iterators
</string>
		<key>optionC</key>
		<string> linked lists in the STL are circular and the loop will never terminate
</string>
		<key>optionD</key>
		<string> the identifier it is a keyword
</string>
		<key>question</key>
		<string>126.Consider the following C++ code segment intended to traverse the list L in reverse order.
          list&lt;int&gt;::iterator  it;
          for(  it = L.end(); it != L.begin(); --it ) {
          	  cout &lt;&lt; *it &lt;&lt; endl;
          }
The code segment will not serve the intended purpose because
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>127</string>
		<key>identifier</key>
		<string>127</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
</string>
		<key>optionB</key>
		<string> I and II
</string>
		<key>optionC</key>
		<string> None
</string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>127.Which of the following statements is (are) true about the locations of a linked list's nodes in memory?
     I. Nodes must appear at a fixed distance from one another in memory.
   II. The order of elements in a list must match the order of the list's nodes in memory.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>128</string>
		<key>identifier</key>
		<string>129</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 14
</string>
		<key>optionB</key>
		<string> 2
</string>
		<key>optionC</key>
		<string> 37
</string>
		<key>optionD</key>
		<string> 40
</string>
		<key>question</key>
		<string>129.Consider the following C++ program segment, which uses the STL.
    stack&lt;int&gt; X;
    X.push(2);
    X.push(14);
    X.pop();
    X.push(37);
    X.push(40);
    X.pop();
    cout &lt;&lt; X.top();
What is the output when this program segment is executed?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>129</string>
		<key>identifier</key>
		<string>130</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> None
</string>
		<key>optionB</key>
		<string> I only
</string>
		<key>optionC</key>
		<string> II only
</string>
		<key>optionD</key>
		<string> I and II
</string>
		<key>question</key>
		<string>130.In order to use the adapter queue from the C++ Standard Template Library, which of the following preprocessor directives is (are) typically required?
   1. #include &lt;queue&gt;
   2. #include &lt;deque&gt;
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>130</string>
		<key>identifier</key>
		<string>131</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only
</string>
		<key>optionB</key>
		<string> II only
</string>
		<key>optionC</key>
		<string> I and II only
</string>
		<key>optionD</key>
		<string> I, II, and III
</string>
		<key>question</key>
		<string>131.Which of the following is (are) typically managed using a stack?
   I. Implementation of function calls in a procedural programming language
   II. Evaluating arithmetic expressions, taking precedence rules into account
   III. Handling jobs sent to a printer, and ensuring that the first jobs to be submitted are printed first
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>131</string>
		<key>identifier</key>
		<string>132</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> singly, forward and backward
</string>
		<key>optionB</key>
		<string> doubly, backward only
</string>
		<key>optionC</key>
		<string> singly, forward only
</string>
		<key>optionD</key>
		<string> doubly, forward only
</string>
		<key>question</key>
		<string>132.The nodes of a _____ linked list can be traversed _____.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>132</string>
		<key>identifier</key>
		<string>133</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> a single use of the operator new allocates memory for the list
</string>
		<key>optionB</key>
		<string> each node contains a pointer to only one other node
</string>
		<key>optionC</key>
		<string> elements must contain unique values
</string>
		<key>optionD</key>
		<string> elements can contain duplicate values
</string>
		<key>question</key>
		<string>133.A singly linked list is a linked list in which
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>133</string>
		<key>identifier</key>
		<string>134</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> a network-socket interface to an STL container
</string>
		<key>optionB</key>
		<string> a pointer to an instance of an STL container
</string>
		<key>optionC</key>
		<string> a new programming interface for an existing STL container
</string>
		<key>optionD</key>
		<string> a wrapper that allows an STL container to be used by the Java programming language
</string>
		<key>question</key>
		<string>134.An STL adapter provides
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>134</string>
		<key>identifier</key>
		<string>135</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only
</string>
		<key>optionB</key>
		<string> I only
</string>
		<key>optionC</key>
		<string> I and II
</string>
		<key>optionD</key>
		<string> None
</string>
		<key>question</key>
		<string>135.Differences between the STL adapter queue and the STL container deque include which of the following?
   I. queue provides support for iterators, whereas deque does not.
   II. queue provides access to only the first and last elements in a collection, whereas deque permits access to an entire collection.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>135</string>
		<key>identifier</key>
		<string>136</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Tree
</string>
		<key>optionB</key>
		<string> Queue
</string>
		<key>optionC</key>
		<string> Stack
</string>
		<key>optionD</key>
		<string> Hash table
</string>
		<key>question</key>
		<string>136.Which of the following data structures uses a "Last-in, First-out" policy for element insertion and removal?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>136</string>
		<key>identifier</key>
		<string>137</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the class list only supports the const version of the bracket operator
</string>
		<key>optionB</key>
		<string> the class list does not support a constructor with given length
</string>
		<key>optionC</key>
		<string> L is an array of 10 list objects, and we cannot assign 555 to a list object
</string>
		<key>optionD</key>
		<string> the class list does not support the bracket operator
</string>
		<key>question</key>
		<string>137.Consider the following code fragment concerning the STL list class.
          list&lt;int&gt;   L(10);
          L[3] = 555;
he fragment will produce a compile time error because
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>137</string>
		<key>identifier</key>
		<string>138</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> None
</string>
		<key>optionB</key>
		<string> I only
</string>
		<key>optionC</key>
		<string> I and II
</string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>138.Which of the following operations is (are) typically more efficient in a linked list than in a vector?
   I. Removal of the first element
   II. Random element access
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>138</string>
		<key>identifier</key>
		<string>139</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> inherited from the superclass Container
</string>
		<key>optionB</key>
		<string> based on arrays of elements
</string>
		<key>optionC</key>
		<string> sequential containers
</string>
		<key>optionD</key>
		<string> random access containers
</string>
		<key>question</key>
		<string>139.One thing that the STL vector and the STL list have in common is that both are 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>139</string>
		<key>identifier</key>
		<string>140</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> None
</string>
		<key>optionB</key>
		<string> I and II
</string>
		<key>optionC</key>
		<string> I only
</string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>140.Which of the following is (are) typically true about linked lists?
   I. Objects in a linked list are stored contiguously in memory.
   II. All elements in a list are copied to new locations in memory upon frontal insertions to the list.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>140</string>
		<key>identifier</key>
		<string>141</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only
</string>
		<key>optionB</key>
		<string> I, II, and III
</string>
		<key>optionC</key>
		<string> None
</string>
		<key>optionD</key>
		<string> III only
</string>
		<key>question</key>
		<string>141.Which of the following is a method (are methods) available in the class queue in the C++ Standard Template Library?
   1. push
   2. pop
   3. enqueue
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>141</string>
		<key>identifier</key>
		<string>142</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
</string>
		<key>optionB</key>
		<string> None
</string>
		<key>optionC</key>
		<string> I and II
</string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>142.Which of the following linear data structures use a first-in, first-out element insertion and removal policy?
   I. Stacks
   II. Queues
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>142</string>
		<key>identifier</key>
		<string>143</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II
</string>
		<key>optionB</key>
		<string> I only
</string>
		<key>optionC</key>
		<string> II only
</string>
		<key>optionD</key>
		<string> None
</string>
		<key>question</key>
		<string>143.Typical implementations for which of the following STL containers store elements contiguously in memory?
   1. vector
   2. list
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>143</string>
		<key>identifier</key>
		<string>144</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
</string>
		<key>optionB</key>
		<string> I and II
</string>
		<key>optionC</key>
		<string> None
</string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>144.Which of the following pointers is (are) stored by nodes in a doubly-linked list?
   I. A pointer to the next node
   II. A pointer to the previous node
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>144</string>
		<key>identifier</key>
		<string>145</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 3
</string>
		<key>optionB</key>
		<string> 1
</string>
		<key>optionC</key>
		<string> 8
</string>
		<key>optionD</key>
		<string> 7
</string>
		<key>question</key>
		<string>145.Consider the following sequence of operations applied to an empty queue:
    Insert element with value 3 
    Insert element with value 8
    Remove element
    Insert element with value 1
    Remove element
    Insert element with value 7
The next element removed from this queue will have which of the following values?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>145</string>
		<key>identifier</key>
		<string>146</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> A compilation error occurs because pop does not return a value.
 </string>
		<key>optionB</key>
		<string> An execution error occurs because an STL stack has no member function pop.
 </string>
		<key>optionC</key>
		<string> Nothing is wrong with the segment.
 </string>
		<key>optionD</key>
		<string> An execution error occurs because pop is a private member function.
</string>
		<key>question</key>
		<string>146. Consider the following C++ program segment, which uses the STL. 	
stack&lt;int&gt; S;
S.push(123);
S.push(456);
cout &lt;&lt; S.pop() &lt;&lt; endl;
Which of the following accurately describes what, if anything, fails in the segment? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>146</string>
		<key>identifier</key>
		<string>147</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> allocate memory for temporary nodes
 </string>
		<key>optionB</key>
		<string> traverse all nodes in the list prior to that element
 </string>
		<key>optionC</key>
		<string> add the element's index to the memory address of the first element in the list
 </string>
		<key>optionD</key>
		<string> compute a hash value for the element 
</string>
		<key>question</key>
		<string>147.To access an element in a singly linked list, a program must 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>147</string>
		<key>identifier</key>
		<string>148</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only
 </string>
		<key>optionB</key>
		<string> I only
 </string>
		<key>optionC</key>
		<string> None
 </string>
		<key>optionD</key>
		<string> I and II  
</string>
		<key>question</key>
		<string>148. The queue adapter interface in the C++ Standard Template Library contains which of the following member functions?
    I.push 
    II.pop_back 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>148</string>
		<key>identifier</key>
		<string>149</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> stepping through the lists in increments of 10
 </string>
		<key>optionB</key>
		<string> adding 10 to each list element
 </string>
		<key>optionC</key>
		<string> inserting a new element 10 after each list element
 </string>
		<key>optionD</key>
		<string> appending 10 to the list  
</string>
		<key>question</key>
		<string>149. Consider the following code fragment, where L is a linked list of integers.
      for( it = L.begin(); it != L.end(); ++it )
        *it += 10;
Execution of this fragment has the effect of
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>149</string>
		<key>identifier</key>
		<string>150</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The length is stored in the first byte of the string.
</string>
		<key>optionB</key>
		<string> The length is stored in the first 4 bytes; the string characters follow this.
</string>
		<key>optionC</key>
		<string> The length is predetermined by the compiler.
</string>
		<key>optionD</key>
		<string> The length is the number of characters preceding a zero.
</string>
		<key>question</key>
		<string>150. In C, how is the length of a character string determined? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>150</string>
		<key>identifier</key>
		<string>151</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> An exception-handler is called with the two operands as parameters.
</string>
		<key>optionB</key>
		<string> The correct value is coerced to a floating point number.
</string>
		<key>optionC</key>
		<string> Execution is terminated.
</string>
		<key>optionD</key>
		<string> An incorrect result is produced and execution continues.
</string>
		<key>question</key>
		<string>151. What happens in a C program when an addition would cause integer overflow? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>151</string>
		<key>identifier</key>
		<string>152</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Integer addition
</string>
		<key>optionB</key>
		<string> Integer multiplication
</string>
		<key>optionC</key>
		<string> Floating-point addition
</string>
		<key>optionD</key>
		<string> Floating-point multiplication
</string>
		<key>question</key>
		<string>152.Which of the following numerical operations is most likely to lead to loss of precision? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>152</string>
		<key>identifier</key>
		<string>153</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 0x5636
</string>
		<key>optionB</key>
		<string> 0x6666
</string>
		<key>optionC</key>
		<string> 0x1030
</string>
		<key>optionD</key>
		<string> 0x1111
</string>
		<key>question</key>
		<string>153.What is the value of the following C expression?
    0x1234 &amp; 0x5432 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>153</string>
		<key>identifier</key>
		<string>154</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> an unpredictable value
</string>
		<key>optionB</key>
		<string> '\n'
</string>
		<key>optionC</key>
		<string> 'g'
</string>
		<key>optionD</key>
		<string> '\0'
</string>
		<key>question</key>
		<string>154. Given the following declaration and initialization of s, what is the value of the expression s[6]?
    char s[] = "string"; 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>154</string>
		<key>identifier</key>
		<string>155</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 11110110
</string>
		<key>optionB</key>
		<string> 10001010
</string>
		<key>optionC</key>
		<string> 11110101
</string>
		<key>optionD</key>
		<string> 11111010
</string>
		<key>question</key>
		<string>155. How is -10 (decimal) represented in an 8-bit 2's complement binary format? </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>155</string>
		<key>identifier</key>
		<string>156</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 0x10002
</string>
		<key>optionB</key>
		<string> 0x10008
</string>
		<key>optionC</key>
		<string> 0x10004
</string>
		<key>optionD</key>
		<string> 8 plus the contents of location 0x10000
</string>
		<key>question</key>
		<string>156. In C, assuming that an int takes 4 bytes, if array a is declared as follows and a has the value 0x10000, what is the value of the expression a + 2?
    int a[12]; 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>156</string>
		<key>identifier</key>
		<string>157</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 00101100
</string>
		<key>optionB</key>
		<string> 00101110
</string>
		<key>optionC</key>
		<string> 00011110
</string>
		<key>optionD</key>
		<string> 01000110
</string>
		<key>question</key>
		<string>157.How is 46 (decimal) represented in an 8-bit 2's complement binary format? 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>157</string>
		<key>identifier</key>
		<string>158</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Memory is accessed in 4-bit chunks.
</string>
		<key>optionB</key>
		<string> Hexadecimal can represent larger numbers than decimal.
</string>
		<key>optionC</key>
		<string> Not all computer numbers can be written in decimal form.
</string>
		<key>optionD</key>
		<string> Hexadecimal digits line up with bit and byte boundaries.
</string>
		<key>question</key>
		<string>158. Which of the following explains why it is convenient to use hexadecimal notation when programming? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>158</string>
		<key>identifier</key>
		<string>159</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 0x4606
</string>
		<key>optionB</key>
		<string> 0x1030
</string>
		<key>optionC</key>
		<string> 0x5434
</string>
		<key>optionD</key>
		<string> 0x5636
</string>
		<key>question</key>
		<string>159.What is the value of the following C expression?
    0x1234 | 0x5432 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>159</string>
		<key>identifier</key>
		<string>160</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only.
 </string>
		<key>optionB</key>
		<string> I only.
 </string>
		<key>optionC</key>
		<string> III only.
 </string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>160. Which of the following are true about statically allocated data in C programs?    I.Its location is chosen by the compiler. 
    II.Its location may change during execution if more memory is required. 
    III.Its location is not known directly but can be found in a static symbol table. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>160</string>
		<key>identifier</key>
		<string>161</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only
 </string>
		<key>optionB</key>
		<string> III only
 </string>
		<key>optionC</key>
		<string> II only
 </string>
		<key>optionD</key>
		<string> I only
</string>
		<key>question</key>
		<string>161. The key feature of implicit memory management is that memory is freed automatically. Which of the following features of C make(s) it difficult to add support for implicit memory management in C? 
    I.Pointers are not always initialized. 
    II.Type casting makes it impossible to know when a value could be a pointer. 
    III.C programs can allocate memory at runtime. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>161</string>
		<key>identifier</key>
		<string>162</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The variable address is invalid after the return.
 </string>
		<key>optionB</key>
		<string> It allows illegal access to the variable from arbitrary functions.
 </string>
		<key>optionC</key>
		<string> The local variable may be in a machine register.
 </string>
		<key>optionD</key>
		<string> It is faster to return the value of the variable. 
</string>
		<key>question</key>
		<string>162. Why is it wrong to return the address of a local variable?  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>162</string>
		<key>identifier</key>
		<string>163</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> failure to free allocated memory
 </string>
		<key>optionB</key>
		<string> bug in which too much memory is allocated, causing internal fragmentation
 </string>
		<key>optionC</key>
		<string> function that allocates a large amount of memory from the heap
 </string>
		<key>optionD</key>
		<string> bug in the memory allocator that fails to free memory  
</string>
		<key>question</key>
		<string>163. A memory leak is caused by a  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>163</string>
		<key>identifier</key>
		<string>164</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> frees memory blocks that cannot be reached by dereferencing pointers.
 </string>
		<key>optionB</key>
		<string> frees all memory blocks that will not be accessed in the future.
 </string>
		<key>optionC</key>
		<string> removes old versions of local variables from the stack .
 </string>
		<key>optionD</key>
		<string> frees memory blocks marked as "deleteable".  
</string>
		<key>question</key>
		<string>164. A garbage collector  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>164</string>
		<key>identifier</key>
		<string>165</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> ptr = ptr + 1; *ptr = x;
 </string>
		<key>optionB</key>
		<string> a[6] = x;
 </string>
		<key>optionC</key>
		<string> a[5] = x; ptr = ptr + 1;
 </string>
		<key>optionD</key>
		<string> ptr = x; *ptr++; 
</string>
		<key>question</key>
		<string>165.In this sequence of C statements 
long a[10];
ptr = a + 5;
*ptr++ = x;
the last line could be rewritten as  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>165</string>
		<key>identifier</key>
		<string>166</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III
 </string>
		<key>optionB</key>
		<string> I and II only
 </string>
		<key>optionC</key>
		<string> II only
 </string>
		<key>optionD</key>
		<string> I only 
</string>
		<key>question</key>
		<string>166. Suppose a compiler uses static storage to store all variables, function parameters, saved registers, and return addresses. Which of the following language features can this compiler support? 
    I.Local variables. 
    II.Function calls. 
    III.Recursion. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>166</string>
		<key>identifier</key>
		<string>166</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III
 </string>
		<key>optionB</key>
		<string> I and II only
 </string>
		<key>optionC</key>
		<string> II only
 </string>
		<key>optionD</key>
		<string> I only 
</string>
		<key>question</key>
		<string>166. Suppose a compiler uses static storage to store all variables, function parameters, saved registers, and return addresses. Which of the following language features can this compiler support? 
    I.Local variables. 
    II.Function calls. 
    III.Recursion. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>167</string>
		<key>identifier</key>
		<string>168</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> only those pointers within the struct that point into the heap are freed automatically.
 </string>
		<key>optionB</key>
		<string> any pointers within the struct are also freed automatically.
 </string>
		<key>optionC</key>
		<string> a destructor function is called automatically to clean up.
 </string>
		<key>optionD</key>
		<string> no pointers within the struct are freed automatically.  
</string>
		<key>question</key>
		<string>168. In C, when a struct is freed,  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>168</string>
		<key>identifier</key>
		<string>169</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Modify free() to set the freed data to zero.
 </string>
		<key>optionB</key>
		<string> Set pointers to NULL after freeing them.
 </string>
		<key>optionC</key>
		<string> Keep a log of addresses that have been freed and scan the log before calling free().
 </string>
		<key>optionD</key>
		<string> Flag all blocks as free or not, and check the flag when calling free().  
</string>
		<key>question</key>
		<string>169. In C, which of the following is the best way to detect when a pointer is freed twice?  
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>169</string>
		<key>identifier</key>
		<string>170</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The sum of m and n
 </string>
		<key>optionB</key>
		<string> The greatest common divisor of m and n
 </string>
		<key>optionC</key>
		<string> The product of m and n
 </string>
		<key>optionD</key>
		<string> The least common multiple of m and n
</string>
		<key>question</key>
		<string>170. Consider the following definition of a recursive function ff in C++. 
int  ff( int n, int m )
{
    if( n == 0 ) return m;
    return  ff( n - 1, m + 1 );
}
Which of the following characterizes the value returned by the call f(n,m)? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>170</string>
		<key>identifier</key>
		<string>171</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Some algorithms could no longer be implemented.
 </string>
		<key>optionB</key>
		<string> All algorithms could still be implemented, but the efficiency would often be catastrophically worse.
 </string>
		<key>optionC</key>
		<string> None
 </string>
		<key>optionD</key>
		<string> All algorithms could still be implemented, but often less elegantly.  
</string>
		<key>question</key>
		<string>171. What would be the consequences for algorithms if recursion were removed from C++? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>171</string>
		<key>identifier</key>
		<string>172</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> odd
 </string>
		<key>optionB</key>
		<string> a power of 2
 </string>
		<key>optionC</key>
		<string> even
 </string>
		<key>optionD</key>
		<string> a prime 
</string>
		<key>question</key>
		<string>172. Consider the following definition of a recursive function f.
      bool  f( int x )
      {
            if( (x &amp; 1) == 1 )  return (x == 1);
            return  f( x &gt;&gt; 1 );               // right shift
      }
The value returned by the call f(x) will determine whether the input x is
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>172</string>
		<key>identifier</key>
		<string>173</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> non-negative
 </string>
		<key>optionB</key>
		<string> even
 </string>
		<key>optionC</key>
		<string> odd
 </string>
		<key>optionD</key>
		<string> unrestricted  
</string>
		<key>question</key>
		<string>173. Consider the following definition of a recursive function f.
      int  f( int x )
      {
            if( x == 0 )  return 1;
            return  x * f( x - 1 );
      }
The inputs for which f will terminate are all x such that x is
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>173</string>
		<key>identifier</key>
		<string>174</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> For all odd inputs x only
 </string>
		<key>optionB</key>
		<string> For all inputs x
 </string>
		<key>optionC</key>
		<string> For all even inputs x only
 </string>
		<key>optionD</key>
		<string> For x = 0 only
</string>
		<key>question</key>
		<string>174.Consider the following definition of a recursive function f.
      int  f( int x )
      {
            if( x == 0 )  return 1;
            return  x * f( x );
      }
For which inputs x will the call f(x) terminate?
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>174</string>
		<key>identifier</key>
		<string>175</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> To obtain short, elegant solutions
 </string>
		<key>optionB</key>
		<string> To use less memory
 </string>
		<key>optionC</key>
		<string> To avoid templates and inheritance
 </string>
		<key>optionD</key>
		<string> To improve efficiency 
</string>
		<key>question</key>
		<string>175. Which of the following is the main reason for using recursion? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>175</string>
		<key>identifier</key>
		<string>176</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only
 </string>
		<key>optionB</key>
		<string> None
 </string>
		<key>optionC</key>
		<string> I only
 </string>
		<key>optionD</key>
		<string> II only  
</string>
		<key>question</key>
		<string>176. Which of the following is (are) true of recursive algorithms and the backtracking problem-solving technique? 
   I.Recursive algorithms implement backtracking by reducing a problem into smaller and smaller sub-problems. 
   II.Recursive algorithms cannot be used to implement backtracking. 
   III.Recursive algorithms that implement backtracking do not typically have a base case.
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>176</string>
		<key>identifier</key>
		<string>177</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> using concurrency to check several possible solutions simultaneously
 </string>
		<key>optionB</key>
		<string> using a breadth-first strategy to search the problem space
 </string>
		<key>optionC</key>
		<string> starting with the set of all possible solutions and working backwards from each to determine which is the actual solution
 </string>
		<key>optionD</key>
		<string> pursuing a possible solution until it is found to be a solution or a non-solution 
</string>
		<key>question</key>
		<string>177. Using a backtracking technique to solve a problem typically involves 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>177</string>
		<key>identifier</key>
		<string>178</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> iteration through looping
 </string>
		<key>optionB</key>
		<string> floating-point division
 </string>
		<key>optionC</key>
		<string> integer division
 </string>
		<key>optionD</key>
		<string> recursion  
</string>
		<key>question</key>
		<string>178.  A divide-and-conquer algorithm typically makes use of 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>178</string>
		<key>identifier</key>
		<string>179</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
 </string>
		<key>optionB</key>
		<string> I and II
 </string>
		<key>optionC</key>
		<string> None
 </string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>179.  Which of the following statements is (are) typical of divide and conquer algorithms? 
   I.Recursive function calls are used to divide a problem into smaller and smaller sub-problems. 
   II.Concurrent programming is used to divide the necessary processing between multiple processors.
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>179</string>
		<key>identifier</key>
		<string>180</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> log2 n
 </string>
		<key>optionB</key>
		<string> 2n
 </string>
		<key>optionC</key>
		<string> 2 * n
 </string>
		<key>optionD</key>
		<string> n2 
</string>
		<key>question</key>
		<string>180. Consider the following definition of a recursive function ff.
      int  ff( int n )
      {
          if( n == 0 ) return 1;
          return  2 * ff( n - 1 );
      }
If n &gt; 0, what is returned by ff( n )?
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>180</string>
		<key>identifier</key>
		<string>181</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> None
 </string>
		<key>optionB</key>
		<string> At most two
 </string>
		<key>optionC</key>
		<string> Any number
 </string>
		<key>optionD</key>
		<string> At most one  
</string>
		<key>question</key>
		<string>181.  How many calls to itself is a recursive function allowed to make? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>181</string>
		<key>identifier</key>
		<string>182</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> uses a binary search to solve a problem
 </string>
		<key>optionB</key>
		<string> uses recursion to test all possible solutions for a problem
 </string>
		<key>optionC</key>
		<string> uses loops to iterate through all possible solutions for a problem
 </string>
		<key>optionD</key>
		<string> splits a problem into two equal halves and uses recursion to solve each half  
</string>
		<key>question</key>
		<string>182.A backtracking algorithm is one that 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>182</string>
		<key>identifier</key>
		<string>183</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 2
 </string>
		<key>optionB</key>
		<string> 1
 </string>
		<key>optionC</key>
		<string> 5
 </string>
		<key>optionD</key>
		<string> 3 
</string>
		<key>question</key>
		<string>183. Consider the function defined as follows.
      int  f( int n )
      {
          if( n == 0 ) return 0;
          if( (n &amp; 1) == 0 ) return f(n/2);
          return f(n/2) + 1;
      }
The value returned by the call f( 10 ); is
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>183</string>
		<key>identifier</key>
		<string>184</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only
 </string>
		<key>optionB</key>
		<string> None
 </string>
		<key>optionC</key>
		<string> I only
 </string>
		<key>optionD</key>
		<string> I and II 
</string>
		<key>question</key>
		<string>184.Which of the following is (are) true of the minimax strategy for deciding the optimal move in a two-person game? 
    I.It assumes that a human player will eventually make a mistake by playing a move that is not optimal. 
   II.It is commonly used with a backtracking algorithm.
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>184</string>
		<key>identifier</key>
		<string>185</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> O(2n)
 </string>
		<key>optionB</key>
		<string> O(n2)
 </string>
		<key>optionC</key>
		<string> O(log n)
 </string>
		<key>optionD</key>
		<string> O(n log n) 
</string>
		<key>question</key>
		<string>185. What is the runtime overhead of a divide-and-conquer algorithm that recursively processes two equal halves of a problem that each have an overhead of O(n)? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>185</string>
		<key>identifier</key>
		<string>186</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> inheritance, methods of the child class
 </string>
		<key>optionB</key>
		<string> recursive function calls, base case of the recursion
 </string>
		<key>optionC</key>
		<string> iteration, body of the loop
 </string>
		<key>optionD</key>
		<string> a process scheduler, individual processes
</string>
		<key>question</key>
		<string>186. Typical divide and conquer algorithms use _____ to divide a problem into smaller sub-problems. The _____ typically solve(s) these sub-problems directly. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>186</string>
		<key>identifier</key>
		<string>187</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
</string>
		<key>optionB</key>
		<string> I and II only.
</string>
		<key>optionC</key>
		<string> III only
</string>
		<key>optionD</key>
		<string> I and III only.
</string>
		<key>question</key>
		<string>187. What properties of a variable are specified by the static keyword in C?
   I. The variable will be statically allocated.
   II. The variable name will be visible only to functions defined within the same file.
   III. The variable's value does not change very often. The compiler uses this fact to focus optimizations on other variables.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>187</string>
		<key>identifier</key>
		<string>188</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only.
</string>
		<key>optionB</key>
		<string> I and III.
</string>
		<key>optionC</key>
		<string> I and II only.
</string>
		<key>optionD</key>
		<string> II only.
</string>
		<key>question</key>
		<string>188. Which of the following features apply to standard heap allocation in C?
   I. The size of heap objects must be known at compile time.
   II. Heap memory must be explicitly allocated.
   III. Heap memory is deallocated when a function returns.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>188</string>
		<key>identifier</key>
		<string>189</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> (*a).b
</string>
		<key>optionB</key>
		<string> (&amp;a).b
</string>
		<key>optionC</key>
		<string> (&amp;a) + b
</string>
		<key>optionD</key>
		<string> *(a + b)
</string>
		<key>question</key>
		<string>189. The C expression a-&gt;b is equivalent to 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>189</string>
		<key>identifier</key>
		<string>190</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> is faster.
</string>
		<key>optionB</key>
		<string> allocates additional memory from the stack.
</string>
		<key>optionC</key>
		<string> detects memory allocation errors.
</string>
		<key>optionD</key>
		<string> sets the contents of the block to zero before returning.
</string>
		<key>question</key>
		<string>190. In C, calloc() differs from malloc() in that calloc() 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>190</string>
		<key>identifier</key>
		<string>191</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The variables are always stored at the same address, determined by the linker.
</string>
		<key>optionB</key>
		<string> The programmer keeps pointers to their location on the heap.
</string>
		<key>optionC</key>
		<string> The variables are located at fixed offsets from a frame pointer.
</string>
		<key>optionD</key>
		<string> The variables are stored at a fixed offset from the program counter.
</string>
		<key>question</key>
		<string>191. In C, how are local variables found at run-time? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>191</string>
		<key>identifier</key>
		<string>192</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> to store the source code line whence each block is allocated.
</string>
		<key>optionB</key>
		<string> to add padding before and after allocated memory blocks and to fill that memory with a known value.
</string>
		<key>optionC</key>
		<string> to ensure that memory blocks are allocated only on word boundaries.
</string>
		<key>optionD</key>
		<string> to check whether the number of calls to malloc() is greater than the number of calls to free(
</string>
		<key>question</key>
		<string>192. To resolve memory leaks in C, one common approach is 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>192</string>
		<key>identifier</key>
		<string>193</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> its last value from the previous call to the function
</string>
		<key>optionB</key>
		<string> 0 (or NULL)
</string>
		<key>optionC</key>
		<string> 0xDEADBEEF
</string>
		<key>optionD</key>
		<string> the value is undefined
</string>
		<key>question</key>
		<string>193. What is the value of an uninitialized pointer variable declared within a function? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>193</string>
		<key>identifier</key>
		<string>194</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the logical "and" of two integer operands.
</string>
		<key>optionB</key>
		<string> the operand unaltered.
</string>
		<key>optionC</key>
		<string> the contents of memory at a given address.
</string>
		<key>optionD</key>
		<string> the address of a data object.
</string>
		<key>question</key>
		<string>194. The unary &amp; operator returns 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>194</string>
		<key>identifier</key>
		<string>195</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> in the heap
</string>
		<key>optionB</key>
		<string> in static storage
</string>
		<key>optionC</key>
		<string> on the stack
</string>
		<key>optionD</key>
		<string> in a fifo
</string>
		<key>question</key>
		<string>195. In C, local variables allocated inside functions are allocated 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>195</string>
		<key>identifier</key>
		<string>196</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Modify free() to set the freed data to zero.
</string>
		<key>optionB</key>
		<string> Flag all blocks as free or not, and check the flag when calling free().
</string>
		<key>optionC</key>
		<string> Keep a log of addresses that have been freed and scan the log before calling free().
</string>
		<key>optionD</key>
		<string> Set pointers to NULL after freeing them
</string>
		<key>question</key>
		<string>196. In C, which of the following is the best way to detect when a pointer is freed twice? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>196</string>
		<key>identifier</key>
		<string>197</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only
</string>
		<key>optionB</key>
		<string> II only
</string>
		<key>optionC</key>
		<string> II and III only
</string>
		<key>optionD</key>
		<string> I only
</string>
		<key>question</key>
		<string>197. Consider the following fragment of C code.
    int *p = (int *) calloc(100);
    int *q = p;
    free(p);
Immediately after executing it, which of the following are true about p and q?
   I. p and q are identical pointers to freed storage.
   II. p points to freed storage, and q points to an allocated block of size 100.
   III. p should not be free()d again, but invoking free(q) is all right.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>197</string>
		<key>identifier</key>
		<string>198</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> coalesce blocks when they are freed.
</string>
		<key>optionB</key>
		<string> keep a linked list of free objects of that type's size.
</string>
		<key>optionC</key>
		<string> minimize the size of the data type.
</string>
		<key>optionD</key>
		<string> use sizes which are powers of two.
</string>
		<key>question</key>
		<string>198.To quickly allocate and free many variables of a commonly used data type, we could 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>198</string>
		<key>identifier</key>
		<string>199</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only
</string>
		<key>optionB</key>
		<string> I and III only
</string>
		<key>optionC</key>
		<string> I, II, and III
</string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>199.Which of the following are advantages of using statistical sampling to profile programs?
   I. Exact run times of all functions can be determined.
   II. Code can be instrumented automatically.
   III. The performance impact due to measurement can be minimal.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>199</string>
		<key>identifier</key>
		<string>200</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> idle time.
</string>
		<key>optionB</key>
		<string> the total duration of a program's execution.
</string>
		<key>optionC</key>
		<string> the user time plus the system time.
</string>
		<key>optionD</key>
		<string> the time a program spends waiting for input and output.
</string>
		<key>question</key>
		<string>200."Wall time" measures 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>200</string>
		<key>identifier</key>
		<string>201</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Write in-line code for string comparison to eliminate a procedure call.
</string>
		<key>optionB</key>
		<string> Call a library function for string comparison.
</string>
		<key>optionC</key>
		<string> Store strings uniquely so that pointer comparison can be used.
</string>
		<key>optionD</key>
		<string> Be sure to use hardware string-comparison instructions.
</string>
		<key>question</key>
		<string>201.Which of the following is likely to offer the best performance improvement for programs that spend 50% of their time comparing strings? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>201</string>
		<key>identifier</key>
		<string>202</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only.
</string>
		<key>optionB</key>
		<string> II only.
</string>
		<key>optionC</key>
		<string> I only.
</string>
		<key>optionD</key>
		<string> I and II only.
</string>
		<key>question</key>
		<string>202. In C and C++, which of the following functions allocate memory from the heap?
   1. printf()
   2. creating a new Standard Template Library string
   3. cout &lt;&lt; "Hello World"
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>202</string>
		<key>identifier</key>
		<string>203</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only
</string>
		<key>optionB</key>
		<string> I, II, and III
</string>
		<key>optionC</key>
		<string> I and II only
</string>
		<key>optionD</key>
		<string> II and III only
</string>
		<key>question</key>
		<string>203. Which of the following are useful for observing program performance?
     I. Direct measurement with a stopwatch.
     II. Statistical Sampling.
     II. System Monitors
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>203</string>
		<key>identifier</key>
		<string>204</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Call a library function for string comparison.
</string>
		<key>optionB</key>
		<string> Write in-line code for string comparison to eliminate a procedure call.
</string>
		<key>optionC</key>
		<string> Be sure to use hardware string-comparison instructions.
</string>
		<key>optionD</key>
		<string> Store strings uniquely so that pointer comparison can be used.
</string>
		<key>question</key>
		<string>204. Which of the following is likely to offer the best performance improvement for programs that spend 50% of their time comparing strings? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>204</string>
		<key>identifier</key>
		<string>205</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Container A is sorted using the function f for assignments.
 </string>
		<key>optionB</key>
		<string> Container A is sorted by applying function f to its elements.
 </string>
		<key>optionC</key>
		<string> Container A is sorted using sorting algorithm f.
 </string>
		<key>optionD</key>
		<string> Container A is sorted using the Boolean valued function f for comparisons
</string>
		<key>question</key>
		<string>205.Consider the following statement using the STL sort() routine.
      sort( A.begin(), A.end(), f );
Which of the following most accurately describes the result of executing this statement?
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>205</string>
		<key>identifier</key>
		<string>206</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Selection sort
 </string>
		<key>optionB</key>
		<string> Quicksort
 </string>
		<key>optionC</key>
		<string> Bubble sort
 </string>
		<key>optionD</key>
		<string> Merge sort  
</string>
		<key>question</key>
		<string>206. Consider the following C++ template function. 
template &lt;class T&gt;
void mystery_sort(vector&lt;T&gt;&amp; v) {
    for (int i = 0; i &lt; v.size() - 1; i++) {
        int best = i;
        for (int j = i + 1; j &lt; v.size(); j++) {
            if (v[j] &lt; v[best]) {
                best = j;
            }
        }
        if (best != i) {
            T temp = v[i];
            v[i] = v[best];
            v[best] = temp;
        }
    }
}
The above function implements which of the following sort algorithms? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>206</string>
		<key>identifier</key>
		<string>207</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 100, 3
 </string>
		<key>optionB</key>
		<string> 10, 1000
 </string>
		<key>optionC</key>
		<string> 3, 100
 </string>
		<key>optionD</key>
		<string> 1000, 10 
</string>
		<key>question</key>
		<string>207. In a search over a data set with 1000 items, the maximum number of items examined by a linear search is _____, and the maximum number of items examined by a binary search is _____. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>207</string>
		<key>identifier</key>
		<string>208</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
 </string>
		<key>optionB</key>
		<string> II only
 </string>
		<key>optionC</key>
		<string> None
 </string>
		<key>optionD</key>
		<string> I and II  
</string>
		<key>question</key>
		<string>208. Which of the following search algorithms can be applied to unsorted data? 
  I. Linear search 
  II.Binary search
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>208</string>
		<key>identifier</key>
		<string>209</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The insertion algorithm cannot find an empty slot in the table.
 </string>
		<key>optionB</key>
		<string> Two key/value pairs have the same value.
 </string>
		<key>optionC</key>
		<string> Two different keys hash to the same slot.
 </string>
		<key>optionD</key>
		<string> The hash function returns a value larger than the table size.
</string>
		<key>question</key>
		<string>209. In the context of hashing, what is meant by a collision? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>209</string>
		<key>identifier</key>
		<string>210</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> an associative hash table
 </string>
		<key>optionB</key>
		<string> a hash map
 </string>
		<key>optionC</key>
		<string> a hash set
 </string>
		<key>optionD</key>
		<string> a hash function 
</string>
		<key>question</key>
		<string>210. A hash table that stores whether or not a key is present, but does not associate any other information with the key, is commonly known as 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>210</string>
		<key>identifier</key>
		<string>211</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> O(n log n)
 </string>
		<key>optionB</key>
		<string> O(n)
 </string>
		<key>optionC</key>
		<string> O(n2)
 </string>
		<key>optionD</key>
		<string> O(n3) 
</string>
		<key>question</key>
		<string>211. Consider the following C++ code fragment.
for( int i = 0; i &lt; n; i += 2 ) {
    for( int j = 0; j &lt; n; j += 3 ) {
        for( int k = 0; k &lt; n; k += 4 ) {
            body;
        }
    }
}
If body executes in constant time, then the asymptotic running time that most closely bounds from above the performance of this code fragment is
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>211</string>
		<key>identifier</key>
		<string>212</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> O(n2)
 </string>
		<key>optionB</key>
		<string> O(n3)
 </string>
		<key>optionC</key>
		<string> O(n log n)
 </string>
		<key>optionD</key>
		<string> O(n) 
</string>
		<key>question</key>
		<string>212.  Consider the following C++ code fragment.
for( int i = 0; i &lt; n; i += 2 ) {
    for(int  j = i; j &gt; 0; j -= 3 ) {
        body
    }
}
If body executes in constant time, then the asymptotic running time that most closely bounds from above the performance of this code fragment is
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>212</string>
		<key>identifier</key>
		<string>213</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> linear
 </string>
		<key>optionB</key>
		<string> quadratic
 </string>
		<key>optionC</key>
		<string> exponential
 </string>
		<key>optionD</key>
		<string> logarithmic
</string>
		<key>question</key>
		<string>213. Consider the following definition of a recursive function, power, that will perform exponentiation.
      int  power( int b, int e )
      {
        if( e == 0 ) return 1;
        if( e % 2 = 0 ) return  power( b * b, e/2 ); 
        return  b * power( b * b, e/2 );
      }
Asymptotically in terms of the exponent e, the number of calls to power that occur as a result of the call power(b,e) is
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>213</string>
		<key>identifier</key>
		<string>214</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II
 </string>
		<key>optionB</key>
		<string> II only
 </string>
		<key>optionC</key>
		<string> I only
 </string>
		<key>optionD</key>
		<string> None 
</string>
		<key>question</key>
		<string>214. Which of the following statements is true of the selection-sort algorithm? 
   I.It is a divide-and-conquer algorithm typically implemented using recursion. 
   II. An implementation of the algorithm typically requires the use of a hash table.
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>214</string>
		<key>identifier</key>
		<string>215</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> O(log n)
 </string>
		<key>optionB</key>
		<string> O(n)
 </string>
		<key>optionC</key>
		<string> O(n2)
 </string>
		<key>optionD</key>
		<string> O(n log n) 
</string>
		<key>question</key>
		<string>215. Consider the following C++ code fragment.
      for( int i = 1; i &lt; n; i *= 2 ) body;
If body executes in O(1) time, then the asymptotic running time that most closely bounds the code fragment above is
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>215</string>
		<key>identifier</key>
		<string>216</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only
 </string>
		<key>optionB</key>
		<string> None
 </string>
		<key>optionC</key>
		<string> I and II
 </string>
		<key>optionD</key>
		<string> I only
</string>
		<key>question</key>
		<string>216. Consider a data set of 100 items. Which of the following is a search algorithm (are search algorithms) that could possibly examine 25 items in this set before succeeding? 
     I. Linear search 
     II. Binary search
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>216</string>
		<key>identifier</key>
		<string>217</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> just the size of the table, templates take care of the rest.
 </string>
		<key>optionB</key>
		<string> the type Thing, a hash function for Thing, and equality testing for Thing.
 </string>
		<key>optionC</key>
		<string> just the type Thing.
 </string>
		<key>optionD</key>
		<string> the type Thing and a hash function for Thing.  
</string>
		<key>question</key>
		<string>217.  For a template hash table class to work with some user-defined key type Thing, the user has to specify 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>217</string>
		<key>identifier</key>
		<string>218</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It should only output prime numbers.
 </string>
		<key>optionB</key>
		<string> It should produce small outputs for small inputs.
 </string>
		<key>optionC</key>
		<string> It should never output a prime number.
 </string>
		<key>optionD</key>
		<string> It should produce apparently random values for given items. 
</string>
		<key>question</key>
		<string>218. Which of the following is true about a good hash function? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>218</string>
		<key>identifier</key>
		<string>219</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> O(1)
 </string>
		<key>optionB</key>
		<string> O(n3)
 </string>
		<key>optionC</key>
		<string> O(n)
 </string>
		<key>optionD</key>
		<string> O(n2) 
</string>
		<key>question</key>
		<string>219. Searching for an element in a linked list containing n elements is most closely bounded from above by 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>219</string>
		<key>identifier</key>
		<string>220</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It is impossible since the algorithm cannot know how to compare two instances of type T.
</string>
		<key>optionB</key>
		<string> It is a reasonable way to implement S.
</string>
		<key>optionC</key>
		<string> It is a poor choice since it does not work with linked lists.
</string>
		<key>optionD</key>
		<string> It is a poor choice since templates slow down sorting.
</string>
		<key>question</key>
		<string>220.Consider the following outline of a template sorting function.
          template&lt;class T&gt;  void  sort( T a[], int n ) { ... }
For a given sorting algorithm S, which of the following is true about using this outline to implement S?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>220</string>
		<key>identifier</key>
		<string>221</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> To store return values of functions, in order to avoid recomputation
</string>
		<key>optionB</key>
		<string> To eliminate recursion in computing function values
</string>
		<key>optionC</key>
		<string> To improve the memory requirements of hash tables
</string>
		<key>optionD</key>
		<string> To speed up access in a hash table
</string>
		<key>question</key>
		<string>221. What is the purpose of using memoizing? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>221</string>
		<key>identifier</key>
		<string>222</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> hash(k)
</string>
		<key>optionB</key>
		<string> hash(v)
</string>
		<key>optionC</key>
		<string> hash() (a random position computed by the hash function using k)
</string>
		<key>optionD</key>
		<string> hash(k,v)
</string>
		<key>question</key>
		<string>222. Suppose hash() is a hash function. The main idea behind hashing is to use a key k to store a value v in which position of a table? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>222</string>
		<key>identifier</key>
		<string>223</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Optimize after all functions are written and debugged.
 </string>
		<key>optionB</key>
		<string> Optimize the more complex functions first.
 </string>
		<key>optionC</key>
		<string> Optimize main() first.
 </string>
		<key>optionD</key>
		<string> "Optimize as you go": make sure every function is optimized before writing the next one.
</string>
		<key>question</key>
		<string>223. Which of the following approaches towards optimizing programs is most advisable?	
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>223</string>
		<key>identifier</key>
		<string>224</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only
</string>
		<key>optionB</key>
		<string> I only
</string>
		<key>optionC</key>
		<string> III only
</string>
		<key>optionD</key>
		<string> II and III only
</string>
		<key>question</key>
		<string>224. A program cannot accidentally "crash" a computer that uses
   I. virtual memory addresses
   II. program relocation
   III. separate instruction and data caches.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>224</string>
		<key>identifier</key>
		<string>225</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only.
</string>
		<key>optionB</key>
		<string> II only.
</string>
		<key>optionC</key>
		<string> I and III only.
</string>
		<key>optionD</key>
		<string> II and III only.
</string>
		<key>question</key>
		<string>225. Compared to static RAM (SRAM), dynamic RAM (DRAM) is
   I. more expensive per megabyte.
   II. slower per word access.
   III. more persistent.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>225</string>
		<key>identifier</key>
		<string>226</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The wall time is still the same on A and B, though it is smaller than before on both of them.
</string>
		<key>optionB</key>
		<string> The wall time is now greater on B than on A.
</string>
		<key>optionC</key>
		<string> It is impossible to change the hit ratio of a program.
</string>
		<key>optionD</key>
		<string> The wall time is now smaller on B than on A.
</string>
		<key>question</key>
		<string>226.A certain program is found to execute with a cache hit ratio of 0.90 on computer A, and of 0.95 on computer B. However, because of other design parameters of these computers, its wall time is the same in both A and B. Then, a clever programmer finds a way to improve the locality of the program, so that it now executes with a hit ratio of 0.92 on A, and of 0.97 on B. Which of the following statements is valid? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>226</string>
		<key>identifier</key>
		<string>227</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> is a way of structuring memory allocation decisions.
</string>
		<key>optionB</key>
		<string> limits programs' size but allows them to execute more quickly.
</string>
		<key>optionC</key>
		<string> takes advantage of the speed of SRAM and the capacity of disk.
</string>
		<key>optionD</key>
		<string> makes programs execute more slowly but allows them to be bigger.
</string>
		<key>question</key>
		<string>227.A memory hierarchy 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>227</string>
		<key>identifier</key>
		<string>228</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> 1088
</string>
		<key>optionB</key>
		<string> 68
</string>
		<key>optionC</key>
		<string> 96
</string>
		<key>optionD</key>
		<string> 17
</string>
		<key>question</key>
		<string>228.Your computer has 32-bit integers and a direct cache containing 128 32-byte cache lines. In the following code fragment, the compiler allocates a at address 0x800000 and b at address 0x801000. Before the execution of the code fragment, the arrays a and b have never been used, so they are not in the cache. What is the minimum number of bytes from each of the arrays a and b that could be fetched into the cache from main memory, during the execution of the code?
    int b[1024];
    int a[1024];
for (i = 0; i &lt; 17; sum += a[i] + b[i], i++)
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>228</string>
		<key>identifier</key>
		<string>229</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
</string>
		<key>optionB</key>
		<string> I, II, and III
</string>
		<key>optionC</key>
		<string> II and III only
</string>
		<key>optionD</key>
		<string> I and III only
</string>
		<key>question</key>
		<string>229.Consider the following fragments from two versions of a program.
            Version A 	           Version B
     for (i = 0 ; i &lt; N ; i++ ) {         for (i = 0 ; i &lt; N ; i++ ) {
           Read(i);                       Read(i);
          Calculate(i);                 }
          Write(i);                for (i = 0 ; i &lt; N ; i++ ) {
      }                                Calculate(i);
                                     }
	                              for (i = 0 ; i &lt; N ; i++ ) {
                                        Write(i);
                                     }
Which of the following are true of version B, compared to version A?
   I. B may be faster because of cache effects.
   II. B may be slower because of cache effects.
   III. B may execute at essentially the same speed as A.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>229</string>
		<key>identifier</key>
		<string>230</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> at about the same speed.
 </string>
		<key>optionB</key>
		<string> about 150% faster.
 </string>
		<key>optionC</key>
		<string> about 100% faster (about 1/3 of the memory accesses are instruction fetches).
 </string>
		<key>optionD</key>
		<string> faster on the internet than off it.
</string>
		<key>question</key>
		<string>230. The 200MHz intel-based processor of a computer with no cache is upgraded to a 500 MHz version of the same processor. On the average, programs now run 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>230</string>
		<key>identifier</key>
		<string>231</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
 </string>
		<key>optionB</key>
		<string> II only
 </string>
		<key>optionC</key>
		<string> I and II only
 </string>
		<key>optionD</key>
		<string> II and III only
</string>
		<key>question</key>
		<string>231 . Which of the following is (are) true of the concept of locality of reference? 
      I.It is used to predict future memory references precisely, with the help of the compiler. 
     II.It is a quality of typical programs. 
     III.It has been mathematically proven. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>231</string>
		<key>identifier</key>
		<string>232</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> exactly 32.
 </string>
		<key>optionB</key>
		<string> at most 96.
 </string>
		<key>optionC</key>
		<string> at most 68.
 </string>
		<key>optionD</key>
		<string> exactly 17
</string>
		<key>question</key>
		<string>232.  When the following code fragment is executed on a computer with 32-bit integers and a fully-associative cache with 32-byte cache lines, how many bytes of the array a will be fetched into the cache from main memory? 
      int a[100];
      for (i = 0; i &lt; 17; sum += a[i], i++);
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>232</string>
		<key>identifier</key>
		<string>233</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only
</string>
		<key>optionB</key>
		<string> II only
</string>
		<key>optionC</key>
		<string> II and III only
</string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>233. Which of the following are effects of a page fault in the program that caused it by, e.g, reading the value of a variable?
   I. An exception is thrown.
   II. A delay occurs.
   III. The program is terminated.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>233</string>
		<key>identifier</key>
		<string>234</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> will disappear when "broadband" communications start delivering data over the internet at speeds greater than 1Mbps.
</string>
		<key>optionB</key>
		<string> will never disappear.
</string>
		<key>optionC</key>
		<string> will disappear once processors reach clock frequencies greater than about 1000MHz.
</string>
		<key>optionD</key>
		<string> will disappear once DRAM speeds improve.
</string>
		<key>question</key>
		<string>234.Current technology trends suggest that the need for memory hierarchies 	
	</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>234</string>
		<key>identifier</key>
		<string>235</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only
</string>
		<key>optionB</key>
		<string> I and III only
</string>
		<key>optionC</key>
		<string> I only
</string>
		<key>optionD</key>
		<string> I, II, and III
</string>
		<key>question</key>
		<string>235. Which facts about the cache can be determined by calling the following function?
    int data[1 &lt;&lt; 20];
    void callee(int x) {
        int i, result;
        for (i = 0; i &lt; (1 &lt;&lt; 20); i += x) {
        result += data[i];
        }
    }
   I. cache line size
   II. cache size
   III. cache speed
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>235</string>
		<key>identifier</key>
		<string>236</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II and III.
</string>
		<key>optionB</key>
		<string> II only.
</string>
		<key>optionC</key>
		<string> I and III only.
</string>
		<key>optionD</key>
		<string> I and II only.
</string>
		<key>question</key>
		<string>236.Two computers A and B with a cache in the CPU chip differ only in that A has an L2 cache and B does not. Which of the following are possible?
   1. B executes a program more quickly than A.
   2. A executes a program more quickly than B.
   3. While executing a program, A fetches more data from main memory than does B.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>236</string>
		<key>identifier</key>
		<string>237</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the pages that the program is actively using
</string>
		<key>optionB</key>
		<string> the memory of the program that is currently in physical memory
</string>
		<key>optionC</key>
		<string> all the files the program needs to execute
</string>
		<key>optionD</key>
		<string> the libraries required by the program
</string>
		<key>question</key>
		<string>237. The working set of a program is formed by 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>237</string>
		<key>identifier</key>
		<string>238</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> CPU registers &lt;--&gt; cache.
</string>
		<key>optionB</key>
		<string> main memory &lt;--&gt; disk.
</string>
		<key>optionC</key>
		<string> cache &lt;--&gt; main memory.
</string>
		<key>optionD</key>
		<string> they all transfer one byte at a time.
</string>
		<key>question</key>
		<string>238. Which of the following levels of a typical memory hierarchy transfers data in chunks of smallest size? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>238</string>
		<key>identifier</key>
		<string>239</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> denying the memory operation that caused the fetch of the new line.
</string>
		<key>optionB</key>
		<string> choosing the cache location currently occupied by the least-recently-used data.
</string>
		<key>optionC</key>
		<string> randomly selecting a cache location for the new line.
</string>
		<key>optionD</key>
		<string> choosing always the same cache location for the new line.
</string>
		<key>question</key>
		<string>239. When a cache is full and a new cache line needs to be fetched into it, which of the following is a pretty good, practical approach? 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>239</string>
		<key>identifier</key>
		<string>240</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Registry.
 </string>
		<key>optionB</key>
		<string> Compiler.
 </string>
		<key>optionC</key>
		<string> Hardware.
 </string>
		<key>optionD</key>
		<string> Operating System.
</string>
		<key>question</key>
		<string>240.Which of the following manages the transfer of data between the cache and main memory? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>240</string>
		<key>identifier</key>
		<string>241</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> No bytes will be fetched from main memory
 </string>
		<key>optionB</key>
		<string> There is no telling, from the information given, how many bytes will be fetched from main memory.
 </string>
		<key>optionC</key>
		<string> Some bytes, but at most 256 Kbytes, will be fetched from main memory.
 </string>
		<key>optionD</key>
		<string> Every instruction fetch will cause a cache miss.
</string>
		<key>question</key>
		<string>241.A program whose code and data together occupy fewer than 256 Kbytes is executed on a computer with a 512 Kbyte direct cache. Which of the following is true? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>241</string>
		<key>identifier</key>
		<string>242</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only
 </string>
		<key>optionB</key>
		<string> I only
 </string>
		<key>optionC</key>
		<string> I and III only
 </string>
		<key>optionD</key>
		<string> II only 
</string>
		<key>question</key>
		<string>242. Which of the following is a shortcoming (are shortcomings) of segmented virtual memory, compared to paged virtual memory? 
    I.It causes external fragmentation. 
    II.It causes internal fragmentation. 
    III.It requires program relocation. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>242</string>
		<key>identifier</key>
		<string>243</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only
 </string>
		<key>optionB</key>
		<string> None
 </string>
		<key>optionC</key>
		<string> III only
 </string>
		<key>optionD</key>
		<string> I, II, and III 
</string>
		<key>question</key>
		<string>243. Two variables of a program are found to be allocated to virtual addresses 0x800000 and 0xA00000 respectively. The program is then executed on a computer that uses paged virtual memory with a page size of 8 KB (0x2000 B). Which of the following are necessarily true? 
     I. The program occupies more than 256 pages of physical memory. 
     II.The program occupies more than 2 MB of physical memory. 
     III.The program occupies more than 10 MB of physical memory. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>243</string>
		<key>identifier</key>
		<string>244</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only
 </string>
		<key>optionB</key>
		<string> II only
 </string>
		<key>optionC</key>
		<string> II and III only
 </string>
		<key>optionD</key>
		<string> I and II only 
</string>
		<key>question</key>
		<string>244. Which of the following are effects of a page fault in a program? Assume that the page fault is caused by the program by reading the value of a variable that belongs to the program, and that the variable is in an unmapped page. 
      I.A hardware exception is thrown and handled by the operating system. 
      II,A delay occurs. 
      III.An exception is thrown that should be handled by the program's source code or the program will terminate. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>244</string>
		<key>identifier</key>
		<string>245</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> more than one program executes concurrently on a single computer.
</string>
		<key>optionB</key>
		<string> one program must terminate before the next program can run.
</string>
		<key>optionC</key>
		<string> there is not enough memory to run all the applications that have been started.
</string>
		<key>optionD</key>
		<string> clocks are properly synchronized in a network of computers.
</string>
		<key>question</key>
		<string>245. Time-sharing occurs when 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>245</string>
		<key>identifier</key>
		<string>246</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> it wastes time that could be used to do useful work.
</string>
		<key>optionB</key>
		<string> it is too complicated to implement
</string>
		<key>optionC</key>
		<string> it leads to interference between two applications accessing the same resource.
</string>
		<key>optionD</key>
		<string> it makes programs much larger.
	Correct answer is 
</string>
		<key>question</key>
		<string>246.Polling is undesirable in a time-shared operating system because 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>246</string>
		<key>identifier</key>
		<string>247</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> a low-priority thread.
</string>
		<key>optionB</key>
		<string> the next available thread.
</string>
		<key>optionC</key>
		<string> a high-priority thread.
</string>
		<key>optionD</key>
		<string> a set of concurrent threads.
</string>
		<key>question</key>
		<string>247.In a real-time application, a time-critical task should be performed by 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>247</string>
		<key>identifier</key>
		<string>248</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only
</string>
		<key>optionB</key>
		<string> I, II, and III
</string>
		<key>optionC</key>
		<string> I and II only
</string>
		<key>optionD</key>
		<string> I only
</string>
		<key>question</key>
		<string>248.For which of the following applications are threads well suited?
    I. Background processing such as data compression or spell-checking
    II.. Displaying a web page on the screen before it has fully arrived from the server
    III. Fetching a page of a web document while the user scrolls through the previous one
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>248</string>
		<key>identifier</key>
		<string>249</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the contents of the cache are mostly irrelevant.
</string>
		<key>optionB</key>
		<string> the cache contents must be saved along with the processor registers.
</string>
		<key>optionC</key>
		<string> the cache must be disabled.
</string>
		<key>optionD</key>
		<string> the contents of the cache are vital for performance.
</string>
		<key>question</key>
		<string>249.When a context switch occurs, 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>249</string>
		<key>identifier</key>
		<string>250</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only
</string>
		<key>optionB</key>
		<string> I, II, and III
</string>
		<key>optionC</key>
		<string> II only
</string>
		<key>optionD</key>
		<string> I and III only
</string>
		<key>question</key>
		<string>250. Which of these are properties of threads?
     I.. Only processes with special privileges can create threads.
     II. Threads eliminate the need to change address spaces in a context switch.
     III. Threads share memory.
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>250</string>
		<key>identifier</key>
		<string>251</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only
</string>
		<key>optionB</key>
		<string> I only
</string>
		<key>optionC</key>
		<string> I, II, and III
</string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>251. In modern operating systems, the malicious behavior of one program should not have any harmful effects on other programs. Which of the following mechanisms support(s) this kind of protection?
   I. Separate address spaces for each application process
   II. Preemptive scheduling administered by the operating system
   III. Free access to input/output device so that they cannot be hoarded
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>251</string>
		<key>identifier</key>
		<string>252</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> long-running processes are assigned lower priorities.
</string>
		<key>optionB</key>
		<string> threads with the earliest deadlines receive higher priorities.
</string>
		<key>optionC</key>
		<string> the scheduler reverses priorities to prevent starvation of low-priority threads.
</string>
		<key>optionD</key>
		<string> a high-priority thread indirectly waits on a lower priority thread.
</string>
		<key>question</key>
		<string>252. Priority inversion is a situation in which	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>252</string>
		<key>identifier</key>
		<string>253</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> only once before variables are reinitialized
</string>
		<key>optionB</key>
		<string> multiple times but only by one thread at a time
</string>
		<key>optionC</key>
		<string> at several points, not only the top
</string>
		<key>optionD</key>
		<string> concurrently by more than one thread
</string>
		<key>question</key>
		<string>253. A reentrant function can be entered 	
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>253</string>
		<key>identifier</key>
		<string>254</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> a modal dialog box is created.
 </string>
		<key>optionB</key>
		<string> the system starts executing a different process.
 </string>
		<key>optionC</key>
		<string> an operating system goes into standby mode.
 </string>
		<key>optionD</key>
		<string> a new stack frame (activation record) is created.
</string>
		<key>question</key>
		<string>254. A context switch occurs when 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>254</string>
		<key>identifier</key>
		<string>255</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
 </string>
		<key>optionB</key>
		<string> I, II, and III
 </string>
		<key>optionC</key>
		<string> I and II only
 </string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>255. For which of the following applications are threads well suited? 
    I.Background processing such as data compression or spell-checking 
    II.Displaying a web page on the screen before it has fully arrived from the server 
    III.Fetching a page of a web document while the user scrolls through the previous one 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>255</string>
		<key>identifier</key>
		<string>256</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> implements password protection to data.
 </string>
		<key>optionB</key>
		<string> limits access to a critical section.
 </string>
		<key>optionC</key>
		<string> temporarily makes memory read-only.
 </string>
		<key>optionD</key>
		<string> prevents execution except in debug mode.
</string>
		<key>question</key>
		<string>256. A lock is a software mechanism that 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>256</string>
		<key>identifier</key>
		<string>257</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the scheduler reverses priorities to prevent starvation of low-priority threads.
 </string>
		<key>optionB</key>
		<string> long-running processes are assigned lower priorities.
 </string>
		<key>optionC</key>
		<string> a high-priority thread indirectly waits on a lower priority thread.
 </string>
		<key>optionD</key>
		<string> threads with the earliest deadlines receive higher priorities.
</string>
		<key>question</key>
		<string>257. Priority inversion is a situation in which 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
</array>
</plist>
