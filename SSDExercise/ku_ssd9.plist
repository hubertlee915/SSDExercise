<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>1</string>
		<key>identifier</key>
		<string>2</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The development of software that conforms to international standards
 </string>
		<key>optionB</key>
		<string> The application of engineering techniques to software production
 </string>
		<key>optionC</key>
		<string> The replacement of hand coding by automatic programming
 </string>
		<key>optionD</key>
		<string> The production of fault-free software that satisfies the user's needs and that is delivered on time and within budget
</string>
		<key>question</key>
		<string>2. What is the goal of software engineering? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>2</string>
		<key>identifier</key>
		<string>3</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The "software depression" began in the 1950s.
 </string>
		<key>optionB</key>
		<string> The Corps of Engineers helped software developers engineer their products.
 </string>
		<key>optionC</key>
		<string> A software crisis emerged in the 1970s and has persisted to this day.
 </string>
		<key>optionD</key>
		<string> Software development was problematic in the beginning, but most of the problems have now been solved.  
</string>
		<key>question</key>
		<string>3. Which of the following is true about the history of software development? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>3</string>
		<key>identifier</key>
		<string>4</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The pace of development is currently about the same in software and hardware technology.
 </string>
		<key>optionB</key>
		<string> Hardware technology progressed very quickly but now software technology is catching up to it.
 </string>
		<key>optionC</key>
		<string> Progress in hardware technology is led by improvements in developing software technology.
 </string>
		<key>optionD</key>
		<string> Hardware technology is outpacing software technology
</string>
		<key>question</key>
		<string>4.  Which of the following accurately characterizes the pace of development of software and hardware technology? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>4</string>
		<key>identifier</key>
		<string>5</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The integration phase   </string>
		<key>optionB</key>
		<string> The design phases  </string>
		<key>optionC</key>
		<string> The implementation phase
 </string>
		<key>optionD</key>
		<string> The maintenance phase  
</string>
		<key>question</key>
		<string>5. In which of the following phases of software development is fixing a fault normally less costly than in any of the others? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>5</string>
		<key>identifier</key>
		<string>6</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The product is interfaced with other software the client uses.
 </string>
		<key>optionB</key>
		<string> The product is adapted to the client's hardware.	 </string>
		<key>optionC</key>
		<string> The entire product is tested.
 </string>
		<key>optionD</key>
		<string> The individual modules are tested
</string>
		<key>question</key>
		<string>6. Which of the following normally happens during the integration phase of software development? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>6</string>
		<key>identifier</key>
		<string>7</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> software will be used by external customers	 </string>
		<key>optionB</key>
		<string> code is written in Java
 </string>
		<key>optionC</key>
		<string> software will be used only once  </string>
		<key>optionD</key>
		<string> code is part of a toolkit produc
</string>
		<key>question</key>
		<string> 7. Creating software that is probably buggy to some extent but which is produced at minimal cost and in minimal time is sometimes acceptable when the 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>7</string>
		<key>identifier</key>
		<string>8</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only   </string>
		<key>optionB</key>
		<string> II and III only  </string>
		<key>optionC</key>
		<string> I, II, and III  </string>
		<key>optionD</key>
		<string> I and II only 
</string>
		<key>question</key>
		<string>8. In the context of software engineering, which of the following definitions are true? 
A failure is the behavior perceived by the user that results from a fault in program code. 
A fault is an actual problem in program code that is causing a failure. 
An error is a programmer's mistake that led to a fault in program code. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>8</string>
		<key>identifier</key>
		<string>9</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only  </string>
		<key>optionB</key>
		<string> II and III only  </string>
		<key>optionC</key>
		<string> I, II, and III  </string>
		<key>optionD</key>
		<string> I and III only 
</string>
		<key>question</key>
		<string>9. Which of the following terms are used to indicate a particular approach or set of techniques for accomplishing one or more specific phases in the software development life cycle? 
A paradigm   A methodology    A method 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>9</string>
		<key>identifier</key>
		<string>10</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> A combination of software products
 </string>
		<key>optionB</key>
		<string> Any software product that can be used without any other software
 </string>
		<key>optionC</key>
		<string> Any set of hardware components on which a software product will run
 </string>
		<key>optionD</key>
		<string> The combination of hardware and software that runs the product  
</string>
		<key>question</key>
		<string>10. In the context of software engineering, what is a system? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>10</string>
		<key>identifier</key>
		<string>11</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It is normally directed by the user at all stages. </string>
		<key>optionB</key>
		<string> It is normally the last step before delivery.
 </string>
		<key>optionC</key>
		<string> Alpha testing is the first step of such assessment.
 </string>
		<key>optionD</key>
		<string> It should be performed throughout the development process. 
</string>
		<key>question</key>
		<string>11.  Which of the following is true about assessment of software quality? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>11</string>
		<key>identifier</key>
		<string>12</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Software crashes are never as important as bridge failures, so the analogy is meaningless.
 </string>
		<key>optionB</key>
		<string> Software design and development should be planned with the same care that is put into designing and building bridges.
 </string>
		<key>optionC</key>
		<string> Building software is so different from building bridges that the analogy should be totally rejected.
 </string>
		<key>optionD</key>
		<string> Building software is quite similar to building bridges, so many aspects of software design and development should be closely modeled on bridge design and construction. 
</string>
		<key>question</key>
		<string>12.  It has been said that software should be engineered like bridges. Of the following, which best describes the value of this analogy? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>12</string>
		<key>identifier</key>
		<string>13</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Production of the requirements document  </string>
		<key>optionB</key>
		<string> Creation of test suites
 </string>
		<key>optionC</key>
		<string> Creation of modular architecture
 </string>
		<key>optionD</key>
		<string> Production of estimates of overall cost and schedule 
</string>
		<key>question</key>
		<string>13.  Which of the following activities takes place during the specification phase of software development? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>13</string>
		<key>identifier</key>
		<string>14</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The repetitive nature of software testing
 </string>
		<key>optionB</key>
		<string> The period of time that a software product is in service
 </string>
		<key>optionC</key>
		<string> The phases that a software product goes through, from idea to obsolescence
 </string>
		<key>optionD</key>
		<string> The cycling through phases of specification, design, implementation, and testing 
</string>
		<key>question</key>
		<string>14.  What is meant by the life cycle of a software product? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>14</string>
		<key>identifier</key>
		<string>15</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Design  </string>
		<key>optionB</key>
		<string> Implementation  </string>
		<key>optionC</key>
		<string> Maintenance  </string>
		<key>optionD</key>
		<string> Specification
</string>
		<key>question</key>
		<string>15. Over the entire life cycle of a software product, which phase typically takes the most time? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>15</string>
		<key>identifier</key>
		<string>16</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Any nontrivial piece of hardware on which software is to be developed
 </string>
		<key>optionB</key>
		<string> Any document directed to the client that is produced during software development
 </string>
		<key>optionC</key>
		<string> Any nontrivial piece of software 
 </string>
		<key>optionD</key>
		<string> The output of a life-cycle phase
</string>
		<key>question</key>
		<string>16.  In the context of software engineering, what is a product? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>16</string>
		<key>identifier</key>
		<string>17</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> individual or organization that pays for the product
 </string>
		<key>optionB</key>
		<string> individual or organization that specifies the software product
 </string>
		<key>optionC</key>
		<string> individual or organization that creates the software product
 </string>
		<key>optionD</key>
		<string> audience for the product  
</string>
		<key>question</key>
		<string>17.  In a software product development context, the developer is the 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>17</string>
		<key>identifier</key>
		<string>18</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> They must be fully specified before coding.
 </string>
		<key>optionB</key>
		<string> They should be developed as coding takes place.
 </string>
		<key>optionC</key>
		<string> Changes in requirements can be easily accommodated after the formal requirements phase.
 </string>
		<key>optionD</key>
		<string> They are normally changed to match the code already produced.
</string>
		<key>question</key>
		<string>18.  Which of the following statements is true of requirements during software development? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>18</string>
		<key>identifier</key>
		<string>19</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only  </string>
		<key>optionB</key>
		<string> II only  </string>
		<key>optionC</key>
		<string> I only  </string>
		<key>optionD</key>
		<string> II and III only 
</string>
		<key>question</key>
		<string>19.  Which of the following are true of the  early days of software development? 
Programming was dominated by considerations of hardware capabilities. 
Programming was considered a science. 
In most programming projects, software development was carefully planned before coding would begin. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>19</string>
		<key>identifier</key>
		<string>19</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only  </string>
		<key>optionB</key>
		<string> II only  </string>
		<key>optionC</key>
		<string> I only  </string>
		<key>optionD</key>
		<string> II and III only 
</string>
		<key>question</key>
		<string>19.  Which of the following are true of the  early days of software development? 
Programming was dominated by considerations of hardware capabilities. 
Programming was considered a science. 
In most programming projects, software development was carefully planned before coding would begin. 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>20</string>
		<key>identifier</key>
		<string>20</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Design  </string>
		<key>optionB</key>
		<string> Requirements analysis  </string>
		<key>optionC</key>
		<string>Specification </string>
		<key>optionD</key>
		<string> Maintenance 
</string>
		<key>question</key>
		<string>20.  Identifying and discussing customer constraints is the primary activity during which of the following phases of software development? 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>21</string>
		<key>identifier</key>
		<string>21</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The client and the developer are in the same organization.
 </string>
		<key>optionB</key>
		<string> The client and the user are in independent organizations.
 </string>
		<key>optionC</key>
		<string> The client and the developer are in independent organizations.Which of the following normally happens during the integration phase of software development
 </string>
		<key>optionD</key>
		<string> The developer and the user are in independent organizations.
</string>
		<key>question</key>
		<string>21.  Which of the following is characteristic of internal software development? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>22</string>
		<key>identifier</key>
		<string>22</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Modules are coded and then the modular architecture is revised.
 </string>
		<key>optionB</key>
		<string> Modules are coded but not tested. </string>
		<key>optionC</key>
		<string> Modules and architecture are documented.
 </string>
		<key>optionD</key>
		<string> Modules are coded and tested.
</string>
		<key>question</key>
		<string>22.  Which of the following normally happens during the implementation phase of software development? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>23</string>
		<key>identifier</key>
		<string>23</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The client and the user are in independent organizations.
 </string>
		<key>optionB</key>
		<string> The client and the developer are in the same organization.
 </string>
		<key>optionC</key>
		<string> The developer and the user are in the same organization.
 </string>
		<key>optionD</key>
		<string> The client and the developer are in independent organizations. 
</string>
		<key>question</key>
		<string>23.  Which of the following characterizes contract software development? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>24</string>
		<key>identifier</key>
		<string>24</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only  </string>
		<key>optionB</key>
		<string> III only  </string>
		<key>optionC</key>
		<string> II and III only  </string>
		<key>optionD</key>
		<string> I, II, and III
</string>
		<key>question</key>
		<string>24. Which of the following participate in a formal review of the specifications document for a software project? 
The developer's SQA group     The client         The specification team 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>25</string>
		<key>identifier</key>
		<string>25</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Generality vs. duration </string>
		<key>optionB</key>
		<string> Generality vs. complexity 
</string>
		<key>optionC</key>
		<string> Complexity vs. cost   </string>
		<key>optionD</key>
		<string> Duration vs. cost   
</string>
		<key>question</key>
		<string>25. Which of the following is an important trade-off that must be kept in mind during the design phase of software development? 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>26</string>
		<key>identifier</key>
		<string>26</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III   </string>
		<key>optionB</key>
		<string> I and II only  </string>
		<key>optionC</key>
		<string> I and III only  </string>
		<key>optionD</key>
		<string> I only   
</string>
		<key>question</key>
		<string>26.  Which of the following are produced during the implementation phase of software development? 
Code    Module documentation    Testing documentation 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>27</string>
		<key>identifier</key>
		<string>27</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> client on the client's hardware with actual data
 </string>
		<key>optionB</key>
		<string> developer on the client's hardware with actual data
 </string>
		<key>optionC</key>
		<string> client on the client's hardware with test data
 </string>
		<key>optionD</key>
		<string> client on the developer's hardware with actual data 
</string>
		<key>question</key>
		<string>27.  In a software development project, acceptance testing is performed by the 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>28</string>
		<key>identifier</key>
		<string>28</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> any modules inside a changed component still communicate correctly
 </string>
		<key>optionB</key>
		<string> a component that was unchanged during changes to other components still performs correctly
 </string>
		<key>optionC</key>
		<string> a module or product hasn't lost code
 </string>
		<key>optionD</key>
		<string> a problem that instigated an attempted fix has indeed been fixed  
</string>
		<key>question</key>
		<string>28.  Regression testing for a software development project is testing to determine whether 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>29</string>
		<key>identifier</key>
		<string>29</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The product will have a short lifetime.  </string>
		<key>optionB</key>
		<string> The customer is willing to pay the money.
 </string>
		<key>optionC</key>
		<string> The customer cannot enunciate the requirements.
 </string>
		<key>optionD</key>
		<string> The product is small and the requirements are simple and well defined.
</string>
		<key>question</key>
		<string>29.  A build-and-fix model for software development is appropriate in which of the following instances? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>30</string>
		<key>identifier</key>
		<string>30</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> all development phases except retirement, sequentially
 </string>
		<key>optionB</key>
		<string> the full set of development phases, sequentially
 </string>
		<key>optionC</key>
		<string> the full set of development phases, in parallel
 </string>
		<key>optionD</key>
		<string> all development phases except retirement, in parallel  
</string>
		<key>question</key>
		<string>30.  The  waterfall model includes _____; the phases are carried out _____. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>31</string>
		<key>identifier</key>
		<string>31</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III  </string>
		<key>optionB</key>
		<string> I and II only  </string>
		<key>optionC</key>
		<string> I only  </string>
		<key>optionD</key>
		<string> I and III only
</string>
		<key>question</key>
		<string>31.  Which of the following are true of the typical rapid prototype? 
It is built quickly.   It is robust.    It is built with the expectation that it will be changed. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>32</string>
		<key>identifier</key>
		<string>32</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the client will feel free to change the requirements too often
 </string>
		<key>optionB</key>
		<string> too much time will be spent testing the incremental functionality
 </string>
		<key>optionC</key>
		<string> the developer will not have enough resources
 </string>
		<key>optionD</key>
		<string> the product will not be tested thoroughly enough at each release  
</string>
		<key>question</key>
		<string>32.  Under the incremental model, the danger of too many builds is that 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>33</string>
		<key>identifier</key>
		<string>33</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only   </string>
		<key>optionB</key>
		<string> I only   </string>
		<key>optionC</key>
		<string> I and III only   </string>
		<key>optionD</key>
		<string> I, II, and III 
</string>
		<key>question</key>
		<string>33. Which of the following are true of the synchronize-and-stabilize model of software development? 
The implementation is divided into 3 to 4 builds. 
A single team works on each build.   It has been used by Microsoft. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>34</string>
		<key>identifier</key>
		<string>34</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only  </string>
		<key>optionB</key>
		<string> II only  </string>
		<key>optionC</key>
		<string> I and II only  </string>
		<key>optionD</key>
		<string> I, II, and III  
</string>
		<key>question</key>
		<string>34.  Which of the following activities are included in a cycle of the spiral? 
Determining objectives, alternatives, constraints 
Evaluating alternatives, and identifying/resolving risks 
Planning the next phase 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>35</string>
		<key>identifier</key>
		<string>35</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It is likely primarily in products implemented in Java.
 </string>
		<key>optionB</key>
		<string> It will not work for all object-oriented products.
 </string>
		<key>optionC</key>
		<string> It may lead to undisciplined development.
 </string>
		<key>optionD</key>
		<string> It focuses excessively on the pre-implementation phases.
</string>
		<key>question</key>
		<string>35.  Which of the following is true of the unconstrained application of an object-oriented life-cycle model?
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>36</string>
		<key>identifier</key>
		<string>36</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> synchronize-and-stabilize model </string>
		<key>optionB</key>
		<string> waterfall model
 </string>
		<key>optionC</key>
		<string> spiral model   </string>
		<key>optionD</key>
		<string> incremental model
</string>
		<key>question</key>
		<string>36.  Frequent integration testing is a feature of the 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>37</string>
		<key>identifier</key>
		<string>37</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Every statement in the specifications document is linked to a statement in the requirements document.
 </string>
		<key>optionB</key>
		<string> Each section in the specifications document explicitly describes how this section depends on other sections.
 </string>
		<key>optionC</key>
		<string> Every statement in the specifications document is well justified and tied to other statements.
 </string>
		<key>optionD</key>
		<string> Each section in the specifications document is signed and dated by a member of the specification team. 
</string>
		<key>question</key>
		<string>37.  For a software development project, what does it mean for specifications to be traceable? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>38</string>
		<key>identifier</key>
		<string>38</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It is an integral part of the software process.
 </string>
		<key>optionB</key>
		<string> It typically begins a few years after the original delivery.
 </string>
		<key>optionC</key>
		<string> It is something to be avoided, wherever and whenever possible.
 </string>
		<key>optionD</key>
		<string> It is typically performed by the user
</string>
		<key>question</key>
		<string>38.  Which of the following is true of maintenance in software development? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>39</string>
		<key>identifier</key>
		<string>39</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only  </string>
		<key>optionB</key>
		<string> II only  </string>
		<key>optionC</key>
		<string> II and III only  </string>
		<key>optionD</key>
		<string> I and III only 
</string>
		<key>question</key>
		<string>39.  Which of the following are true of the build-and-fix model of software development? 
Several iterations of building and reviewing are typically required. 
Two or three iterations of the product are typically sufficient. 
The product is typically built without specifications or preceding design. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>40</string>
		<key>identifier</key>
		<string>40</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Build-and-fix model     </string>
		<key>optionB</key>
		<string> Rapid prototyping model 
</string>
		<key>optionC</key>
		<string> Spiral model     </string>
		<key>optionD</key>
		<string> Waterfall model 
</string>
		<key>question</key>
		<string>40.  Until the 1980s, the only widely accepted life-cycle model of software development was the 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>41</string>
		<key>identifier</key>
		<string>41</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III </string>
		<key>optionB</key>
		<string> III only </string>
		<key>optionC</key>
		<string> I only </string>
		<key>optionD</key>
		<string> I and III only
</string>
		<key>question</key>
		<string>41.  Which of the following are true of rapid prototyping? 
It can serve as a focal point for discussing requirements with the client. 
It can help shorten product development by allowing the developer to bypass the design phase. 
It can help mitigate technical risk by uncovering unforeseen problems with the proposed technology. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>42</string>
		<key>identifier</key>
		<string>42</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> III only </string>
		<key>optionC</key>
		<string> II only </string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>42.  The incremental model may degenerate into the build-and-fix approach under which of the following circumstances?    
The overall development time becomes too long. 
There are too many builds.   The requirements change too rapidly. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>43</string>
		<key>identifier</key>
		<string>43</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> I and III only </string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>43.  Which of the following advantages are true of the synchronize-and-stabilize model of software development? 
Testing occurs early and often. 
There is always a working version, although it may be incomplete. 
There is early feedback on design. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>44</string>
		<key>identifier</key>
		<string>44</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> ability of software developers to estimate risk accurately
 </string>
		<key>optionB</key>
		<string> willingness of the client to live with some uncertainty
 </string>
		<key>optionC</key>
		<string> flexibility of the client's requirements
 </string>
		<key>optionD</key>
		<string> ability to develop a prototype for each phase 
</string>
		<key>question</key>
		<string>44.  A crucial factor in the success of the spiral model is 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>45</string>
		<key>identifier</key>
		<string>45</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> spiral model </string>
		<key>optionB</key>
		<string> synchronize-and-stabilize model </string>
		<key>optionC</key>
		<string> waterfall model </string>
		<key>optionD</key>
		<string> fountain model 
</string>
		<key>question</key>
		<string>45.  One life-cycle model that incorporates features of all other models is the 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>46</string>
		<key>identifier</key>
		<string>46</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It is a basis for the specification document.
 </string>
		<key>optionB</key>
		<string> It is a legally binding contract between the client and the developer.
 </string>
		<key>optionC</key>
		<string> It includes detailed cost estimates.
 </string>
		<key>optionD</key>
		<string> It will not change through the life cycle of the software product.
</string>
		<key>question</key>
		<string>46.  Which of the following is true of the requirements document for a software project? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>47</string>
		<key>identifier</key>
		<string>47</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Each design choice, except choices of low-level detail, must be described by the relevant data structures and algorithms.
 </string>
		<key>optionB</key>
		<string> Each design choice, except choices of low-level detail, must be linked to statements in the specifications document, and each statement in the specification document must be reflected in some aspect of the design.
 </string>
		<key>optionC</key>
		<string> Each design choice, except choices of low-level detail, must be attributed to a particular member of the design team.
 </string>
		<key>optionD</key>
		<string> Each design choice, except choices of low-level detail, must be linked to statements in the requirements document and each statement in the requirements document must be reflected in some aspect of the design
</string>
		<key>question</key>
		<string>47.  Which of the following defines traceability of the design document? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>48</string>
		<key>identifier</key>
		<string>48</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> III only  
</string>
		<key>question</key>
		<string>48.  Which of the following kinds of documentation should be produced as part of the implementation phase of software development? 
The user-reference manual 
A test document describing all the test cases for implementation 
A description of all interfaces 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>49</string>
		<key>identifier</key>
		<string>49</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Alpha testing occurs onsite and beta testing occurs offsite.
 </string>
		<key>optionB</key>
		<string> Both are rare. </string>
		<key>optionC</key>
		<string> Both occur in-house. 
</string>
		<key>optionD</key>
		<string> Both occur at potential future customers' sites. 
</string>
		<key>question</key>
		<string>49. Which of the following is true of alpha and beta testing of a shrink-wrapped software product? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>50</string>
		<key>identifier</key>
		<string>50</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only 
</string>
		<key>optionB</key>
		<string> I only
</string>
		<key>optionC</key>
		<string> I and IIIonly 
</string>
		<key>optionD</key>
		<string> I, II, and III
</string>
		<key>question</key>
		<string>50. Which of the following changes are typically carried out during the maintenance phase of the software life cycle?
Problem fixes        Addition of functionality       Improvements in performance 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>51</string>
		<key>identifier</key>
		<string>51</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III </string>
		<key>optionB</key>
		<string> I and III only </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> III only 
</string>
		<key>question</key>
		<string>51. Which of the following disadvantages are true of the build-and-fix model of software development? 
Flaws in specifications, design, and implementation are typically not discovered until the whole thing is complete. 
Changes to completed modules will typically be much more expensive than changes to other models. 
The product is typically difficult to understand and maintain. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>52</string>
		<key>identifier</key>
		<string>52</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> it supports influence from earlier phases to later phases
 </string>
		<key>optionB</key>
		<string> implementation and integration usually occur in parallel
 </string>
		<key>optionC</key>
		<string> implementation cannot begin until specifications are completed
 </string>
		<key>optionD</key>
		<string> it supports feedback from later phases to earlier phases
</string>
		<key>question</key>
		<string>52.  A defining characteristic of the waterfall model is that 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>53</string>
		<key>identifier</key>
		<string>53</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> build-and-fix model
</string>
		<key>optionB</key>
		<string> rapid prototyping model
 </string>
		<key>optionC</key>
		<string> synchronize-and-stabilize model 
  </string>
		<key>optionD</key>
		<string> incremental mode
</string>
		<key>question</key>
		<string>53. For a software development project, a good way of making sure that the client's needs are met is to use the 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>54</string>
		<key>identifier</key>
		<string>54</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The people who maintain the code need documentation to understand it.
 </string>
		<key>optionB</key>
		<string> The client will not accept undocumented code.
 </string>
		<key>optionC</key>
		<string> Code documentation is necessary for design.
 </string>
		<key>optionD</key>
		<string> Documentation is part of the requirements for the software product.
</string>
		<key>question</key>
		<string>54.  What is the most important reason for producing documentation for program code for a software product? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>55</string>
		<key>identifier</key>
		<string>55</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only </string>
		<key>optionB</key>
		<string> I only </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> III only 
</string>
		<key>question</key>
		<string>55. Which of the following are true of one-of-a-kind software product development? 
Alpha testing takes place in a controlled environment. 
Beta testing takes place at the developer's site. 
Alpha testing takes place at the client's site. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>56</string>
		<key>identifier</key>
		<string>56</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only </string>
		<key>optionB</key>
		<string> I and II only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> II and III only
</string>
		<key>question</key>
		<string>56.  Dangers of rapid prototyping include which of the following? 
The client may come to expect that the final product can be changed as easily as the prototype. 
Developers may be tempted to reuse the prototype code for the final product. 
The prototype may not elicit requirements from the client as clearly as necessary. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>57</string>
		<key>identifier</key>
		<string>57</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> I and II only </string>
		<key>optionC</key>
		<string> II only </string>
		<key>optionD</key>
		<string> I, II, and III
</string>
		<key>question</key>
		<string>57. Which of the following drawbacks pertain to informal specifications? 
They may be verbose and hard to follow. 
It is hard to gauge whether they are complete. 
Inconsistencies may be difficult to detect. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>58</string>
		<key>identifier</key>
		<string>58</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> I and II only  
</string>
		<key>question</key>
		<string>58.  Which of the following are true about a DFD? 
They can be replaced by control flow diagrams in certain applications. 
The principle of hierarchical partitioning applies to DFDs. 
The principle of movement from essentials to details applies to DFDs. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>59</string>
		<key>identifier</key>
		<string>59</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> integration testing </string>
		<key>optionB</key>
		<string> requirements analysis </string>
		<key>optionC</key>
		<string> design </string>
		<key>optionD</key>
		<string> specification 
</string>
		<key>question</key>
		<string>59.  The use of dataflow diagrams (DFDs) is a _____ technique. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>60</string>
		<key>identifier</key>
		<string>60</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> control flow, all kinds of software systems
 </string>
		<key>optionB</key>
		<string> data flow, all kinds of software systems
 </string>
		<key>optionC</key>
		<string> data flow, real time systems  </string>
		<key>optionD</key>
		<string> control flow, real time systems 
</string>
		<key>question</key>
		<string>60.  State transitions diagrams are used to specify _____ for _____. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>61</string>
		<key>identifier</key>
		<string>61</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> information that the SQA group attaches to specifications for tracing purposes
 </string>
		<key>optionB</key>
		<string> constraints on the product imposed by the client
 </string>
		<key>optionC</key>
		<string> specific conditional branching and looping inside individual processes
 </string>
		<key>optionD</key>
		<string> how different input or input states cause different processes to be activated 
</string>
		<key>question</key>
		<string>61.  The control information found in a state transition diagram describes 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>62</string>
		<key>identifier</key>
		<string>62</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> II only </string>
		<key>optionD</key>
		<string> I, II, and III  
</string>
		<key>question</key>
		<string>62.  Which of the following are among the uses of a data dictionary? 
Run-time debugging of programs 
Determining display requirements of data 
Checking consistency between design/implementation and specifications 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>63</string>
		<key>identifier</key>
		<string>63</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> I and II only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> I only 
</string>
		<key>question</key>
		<string>63.  What type of information is typically stored in the data dictionary? 
The type of a data item ///The preset values of a data item ///Where and how the data item is used 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>64</string>
		<key>identifier</key>
		<string>64</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the data in the form fields only
 </string>
		<key>optionB</key>
		<string> the data in the form fields and the commit or cancel action
 </string>
		<key>optionC</key>
		<string> part of the data in the form fields and the commit or cancel action
 </string>
		<key>optionD</key>
		<string> the commit or cancel action only
</string>
		<key>question</key>
		<string>64.  The input-output specification for a forms interface to a database includes 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>65</string>
		<key>identifier</key>
		<string>65</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It should attempt to detect the illegal input before processing and ask the user to correct input.
 </string>
		<key>optionB</key>
		<string> It should raise a system error during processing and end the program.
 </string>
		<key>optionC</key>
		<string> It should raise a system error during processing and wait for user correction.
 </string>
		<key>optionD</key>
		<string> It should end the program after telling the user why the data is bad.
</string>
		<key>question</key>
		<string>65.  Which of the following describes the way a software product should react to incorrect and/or incomplete input? 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>66</string>
		<key>identifier</key>
		<string>66</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> mandatory, optional </string>
		<key>optionB</key>
		<string> optional, optional 
</string>
		<key>optionC</key>
		<string> mandatory, mandatory </string>
		<key>optionD</key>
		<string> optional, mandatory 
</string>
		<key>question</key>
		<string>66.  Suppose that a database model for job seekers has three main entities, people, skills, and jobs. Suppose also that the people must have one or more skills, while jobs require zero or more skills. Then the modalities for the relationships HAS_SKILL and REQUIRES_SKILL are, respectively, _____ and _____. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>67</string>
		<key>identifier</key>
		<string>67</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> process logic </string>
		<key>optionB</key>
		<string> data objects </string>
		<key>optionC</key>
		<string> control flow </string>
		<key>optionD</key>
		<string> data flow
</string>
		<key>question</key>
		<string>67.  Entity-relationship modeling is a formal technique oriented to modeling 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>68</string>
		<key>identifier</key>
		<string>68</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> II only </string>
		<key>optionD</key>
		<string> I and II only 
</string>
		<key>question</key>
		<string>68.  Which of the following are typically true of informal specifications? 
They are often written as a set of if-then clauses. 
They are written in a natural language. 
They are only used in conjunction with more formal techniques. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>69</string>
		<key>identifier</key>
		<string>69</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> how data flows into and out of a software product but not within
 </string>
		<key>optionB</key>
		<string> how data flows into, out of, and within a software product
 </string>
		<key>optionC</key>
		<string> the data structures used by a software product
 </string>
		<key>optionD</key>
		<string> the flow of control in a software product 
</string>
		<key>question</key>
		<string>69.  Dataflow diagrams (DFDs) show 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>70</string>
		<key>identifier</key>
		<string>70</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> II only </string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>70.  Successive levels of DFDs can be shown using which of the following? 
External refinement ///In-place refinement ////Hierarchical annotations 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>71</string>
		<key>identifier</key>
		<string>71</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The way that data flows between and within component processes of a system
 </string>
		<key>optionB</key>
		<string> The way that control flows between and within component processes of a system
 </string>
		<key>optionC</key>
		<string> The way that a module implements a particular algorithm
 </string>
		<key>optionD</key>
		<string> The way that a system controls another system 
</string>
		<key>question</key>
		<string>71.  Process logic describes which of the following? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>72</string>
		<key>identifier</key>
		<string>72</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III </string>
		<key>optionB</key>
		<string> I and II only </string>
		<key>optionC</key>
		<string> I and III only </string>
		<key>optionD</key>
		<string> II and III only
</string>
		<key>question</key>
		<string>72.  Which of the following statements are true about decision trees? 
They help detect whether all possible combinations of input have been handled. 
They are good for specifying non-iterative decision procedures. 
They are generally used for real time systems. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>73</string>
		<key>identifier</key>
		<string>73</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> whether an item is optional or mandatory </string>
		<key>optionB</key>
		<string> the use of a data item
 </string>
		<key>optionC</key>
		<string> the type of a data item </string>
		<key>optionD</key>
		<string> the number of values that a data item can take on 
</string>
		<key>question</key>
		<string>73.  Within the context of a data dictionary, the term modality refers to 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>74</string>
		<key>identifier</key>
		<string>74</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> one-to-many </string>
		<key>optionB</key>
		<string> many-to-many </string>
		<key>optionC</key>
		<string> one-to-one </string>
		<key>optionD</key>
		<string> many-to-one
</string>
		<key>question</key>
		<string>74.  If a department can have several employees and an employee can work for only one department, then the relationship WORKS_FOR from employee to department is 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>75</string>
		<key>identifier</key>
		<string>75</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> diagram </string>
		<key>optionB</key>
		<string> logic </string>
		<key>optionC</key>
		<string> narrative </string>
		<key>optionD</key>
		<string> data dictionary
</string>
		<key>question</key>
		<string>75.  Entity-relationship modeling is usually expressed using an entity-relationship 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>76</string>
		<key>identifier</key>
		<string>76</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> When the design team is able to produce algorithms to match the DFDs
 </string>
		<key>optionB</key>
		<string> When the client and the developer's SQA group approve the existing DFDs
 </string>
		<key>optionC</key>
		<string> When the graphical representation can no longer show details effectively
 </string>
		<key>optionD</key>
		<string> When further decomposition would require entering into algorithm design
</string>
		<key>question</key>
		<string>76.  When should the process of refining a DFD stop? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>77</string>
		<key>identifier</key>
		<string>77</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> they use less paper than descriptive text
 </string>
		<key>optionB</key>
		<string> software developers like them better than text
 </string>
		<key>optionC</key>
		<string> clients understand them better than text
 </string>
		<key>optionD</key>
		<string> they are less ambiguous than descriptive text 
</string>
		<key>question</key>
		<string>77.  The most important reason for using graphical representations like DFDs is that 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>78</string>
		<key>identifier</key>
		<string>78</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> find </string>
		<key>optionB</key>
		<string> describe </string>
		<key>optionC</key>
		<string> operate on </string>
		<key>optionD</key>
		<string> store 
</string>
		<key>question</key>
		<string>78.  A data dictionary is primarily used to _____ the data processed by a software product. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>79</string>
		<key>identifier</key>
		<string>79</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> I only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> I and III only
</string>
		<key>question</key>
		<string>79.  In OOA, which of the following are possible user roles in use case modeling? 
The end user of the software //The software maintainer //Remote Web servers 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>80</string>
		<key>identifier</key>
		<string>80</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> extract candidate objects from the use case scenarios
 </string>
		<key>optionB</key>
		<string> create an object diagram in UML
 </string>
		<key>optionC</key>
		<string> create and refine the preliminary class list
 </string>
		<key>optionD</key>
		<string> specify the classes along with their attributes and methods  
</string>
		<key>question</key>
		<string>80.  In object-oriented analysis, the second step of the class-modeling phase is to 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>81</string>
		<key>identifier</key>
		<string>81</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> In the use case scenarios </string>
		<key>optionB</key>
		<string> Using a graphical notation
 </string>
		<key>optionC</key>
		<string> In a written specification </string>
		<key>optionD</key>
		<string> As a set of (state, event, predicate, new state) rules
</string>
		<key>question</key>
		<string>81.  During the dynamic modeling phase of OOA, how is state transition information most often represented? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>82</string>
		<key>identifier</key>
		<string>82</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> I and III only 
</string>
		<key>question</key>
		<string>82.  In OOA, it is important to model different user roles for which of the following reasons? 
They may imply different use cases. 
Different users have different skill levels. 
The system may be integrated with external software. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>83</string>
		<key>identifier</key>
		<string>83</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> rectangle </string>
		<key>optionB</key>
		<string> arrow </string>
		<key>optionC</key>
		<string> oval </string>
		<key>optionD</key>
		<string> stick figure
</string>
		<key>question</key>
		<string>83.  In a use case diagram, a system boundary is represented by a labeled 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>84</string>
		<key>identifier</key>
		<string>84</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> I only 
</string>
		<key>question</key>
		<string>84.  Abnormal use case scenarios capture events such as which of the following? 
Network errors /////Unexpected input data ////Software compilation errors 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>85</string>
		<key>identifier</key>
		<string>85</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> II only </string>
		<key>optionC</key>
		<string> III only </string>
		<key>optionD</key>
		<string> I and III only 
</string>
		<key>question</key>
		<string>85.  Which of the following is (are) true about noun extraction in class modeling? 
It is a process that identifies the attributes in the class model. 
It is a textual analysis that identifies candidate objects. 
It is the first step in class modeling. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>86</string>
		<key>identifier</key>
		<string>86</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> labeled arrow </string>
		<key>optionB</key>
		<string> line labeled with cardinality information
 </string>
		<key>optionC</key>
		<string> labeled oval </string>
		<key>optionD</key>
		<string> partitioned rectangle   
</string>
		<key>question</key>
		<string>86.  In an object diagram, an inheritance relation is represented as a 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>87</string>
		<key>identifier</key>
		<string>87</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> labeled arrow
 </string>
		<key>optionB</key>
		<string> rounded rectangle 
</string>
		<key>optionC</key>
		<string> solid circle
 </string>
		<key>optionD</key>
		<string> set of predicates in square brackets
</string>
		<key>question</key>
		<string>87.  In a state transition diagram, a state is represented as a 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>88</string>
		<key>identifier</key>
		<string>88</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> A set of use cases is written for each scenario.
 </string>
		<key>optionB</key>
		<string> Every use case has only one possible scenario.
 </string>
		<key>optionC</key>
		<string> A use case is an instance of a scenario.
 </string>
		<key>optionD</key>
		<string> A scenario is an instance of a use case
</string>
		<key>question</key>
		<string>88.  Which of the following is true of use case modeling in OOA? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>89</string>
		<key>identifier</key>
		<string>89</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> specify the classes along with their attributes and methods
 </string>
		<key>optionB</key>
		<string> create and refine the preliminary class list
 </string>
		<key>optionC</key>
		<string> extract candidate objects from the use case scenarios
 </string>
		<key>optionD</key>
		<string> create an object diagram in UML   
</string>
		<key>question</key>
		<string>89.  In object-oriented analysis, the third step of the class-modeling phase is to 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>90</string>
		<key>identifier</key>
		<string>90</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only </string>
		<key>optionB</key>
		<string> I and III only </string>
		<key>optionC</key>
		<string> II and III only </string>
		<key>optionD</key>
		<string> III only
</string>
		<key>question</key>
		<string>90.  In a use case diagram, the &lt;&lt;uses relationship is used to identify 
External systems that are invoked by a use case 
Use cases that are invoked by the end user 
A primary use case that is invoked by other use cases 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>91</string>
		<key>identifier</key>
		<string>91</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> I and III only </string>
		<key>optionC</key>
		<string> II and III only </string>
		<key>optionD</key>
		<string> I, II, and III 
</string>
		<key>question</key>
		<string>91.  Following noun extraction, some candidate classes are left out of the class diagram for which of the following reasons? 
They fall outside the scope of the software to be built. 
They correspond to abstract objects. 
They refer to class variables. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>92</string>
		<key>identifier</key>
		<string>92</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> in the requirements specification    </string>
		<key>optionB</key>
		<string> in the entity-relationship diagram
 </string>
		<key>optionC</key>
		<string> during the design phase    </string>
		<key>optionD</key>
		<string> during dynamic modeling  
</string>
		<key>question</key>
		<string>92.  The details regarding class methods and attributes are specified 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>93</string>
		<key>identifier</key>
		<string>93</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> II only </string>
		<key>optionC</key>
		<string> III only </string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>93.  Which of the following is (are) true about a state transition diagram? 
Transitions are represented by rounded rectangles. 
Transitions are represented by labeled arrows. 
Each transition is labeled with a set of predicates in square brackets. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>94</string>
		<key>identifier</key>
		<string>94</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> I and III only </string>
		<key>optionC</key>
		<string> II and III only </string>
		<key>optionD</key>
		<string> I, II, and III 
</string>
		<key>question</key>
		<string>94.  Which of the following is (are) true of abnormal use case scenarios in OOA? 
They specify error messages produced by the software. 
They capture unexpected events that might happen during a use case. 
They are important for a comprehensive specification. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>95</string>
		<key>identifier</key>
		<string>95</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> I and III only </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>95.  The state transition diagram is used to 
Specify the different events that the software must respond to 
Identify the actions associated with all of the states the software can be in 
Specify the methods for each object in the class diagram 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>96</string>
		<key>identifier</key>
		<string>96</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> I and III only </string>
		<key>optionC</key>
		<string> I only </string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>96.  A use case scenario can be 
A textual description of a software function or behavior 
A list of the different users who will use the software 
A specification of unexpected system behaviors 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>97</string>
		<key>identifier</key>
		<string>97</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> labeled oval </string>
		<key>optionB</key>
		<string> line labeled with cardinality information </string>
		<key>optionC</key>
		<string> labeled arrow
 </string>
		<key>optionD</key>
		<string> partitioned rectangle 
</string>
		<key>question</key>
		<string>97.  In an object diagram, a relation between two classes is represented as a 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>98</string>
		<key>identifier</key>
		<string>98</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> rounded rectangle </string>
		<key>optionB</key>
		<string> labeled diamond </string>
		<key>optionC</key>
		<string> solid circle </string>
		<key>optionD</key>
		<string> square 
</string>
		<key>question</key>
		<string>98.  In a state transition diagram, a start state is represented by a 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>99</string>
		<key>identifier</key>
		<string>99</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The most emphasis is given to the algorithms that relate the structure of the data to the actions operating on the data.
 </string>
		<key>optionB</key>
		<string> Equal emphasis is given to the structure of the data and the actions operating on the data.
 </string>
		<key>optionC</key>
		<string> More emphasis is given to the actions operating on the data than to the structure of the data.
 </string>
		<key>optionD</key>
		<string> More emphasis is given to the structure of the data than to the actions operating on the data.
</string>
		<key>question</key>
		<string>99.  Which of the following is true about object-oriented design? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>100</string>
		<key>identifier</key>
		<string>100</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III </string>
		<key>optionB</key>
		<string> I and II only </string>
		<key>optionC</key>
		<string> II and III only </string>
		<key>optionD</key>
		<string> I and III only  
</string>
		<key>question</key>
		<string>100.  The architectural design of a software system is used during which of the following phases of software construction? 
Requirements specification ///Detailed design /// System implementation and testing 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>101</string>
		<key>identifier</key>
		<string>101</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> II and III only </string>
		<key>optionD</key>
		<string> I and III only
</string>
		<key>question</key>
		<string>101.  The products of the detailed design phase include which of the following? 
Module algorithms ///Code for Java classes //// Module interfaces 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>102</string>
		<key>identifier</key>
		<string>102</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> allow graphical analysis of system modules
 </string>
		<key>optionB</key>
		<string> support graphical display of class diagrams
 </string>
		<key>optionC</key>
		<string> allow the user to enter information about modular interfaces
 </string>
		<key>optionD</key>
		<string> cross reference specifications and design elements
</string>
		<key>question</key>
		<string>102.  Some CASE tools are useful for design testing because they 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>103</string>
		<key>identifier</key>
		<string>103</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> II and III only </string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>103.  Interaction diagrams include which of the following? 
Collaboration diagrams ///Entity-relationship diagrams ///Sequence diagrams 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>104</string>
		<key>identifier</key>
		<string>104</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the text of a message passed between objects
 </string>
		<key>optionB</key>
		<string> a directed line (arrow) between objects </string>
		<key>optionC</key>
		<string> a solid line between objects
 </string>
		<key>optionD</key>
		<string> a dotted line between objects
</string>
		<key>question</key>
		<string>104.  In a collaboration diagram, coupling between objects is represented by 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>105</string>
		<key>identifier</key>
		<string>105</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Details about inner classes </string>
		<key>optionB</key>
		<string> Private methods
 </string>
		<key>optionC</key>
		<string> Information hiding  </string>
		<key>optionD</key>
		<string> Details about class methods  
</string>
		<key>question</key>
		<string>105.  A detailed class diagram is created from the preliminary class diagram by adding which of the following? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>106</string>
		<key>identifier</key>
		<string>106</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> an unlabeled, directed line (arrow) from client to object
 </string>
		<key>optionB</key>
		<string> an unlabeled, directed line (arrow) from object to client
 </string>
		<key>optionC</key>
		<string> a labeled rectangle
 </string>
		<key>optionD</key>
		<string> an unlabeled rectangle 
</string>
		<key>question</key>
		<string>106. In a client-object diagram, a relation is represented as 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>107</string>
		<key>identifier</key>
		<string>107</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> I and III only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> II and III only
</string>
		<key>question</key>
		<string>107.  A skeletal Java class file can be used to specify which of the following? 
Method signatures ///Detailed design information /////Detailed class diagrams 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>108</string>
		<key>identifier</key>
		<string>108</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> They can be linked to libraries. </string>
		<key>optionB</key>
		<string> They are conveniently organized for the programmer.
 </string>
		<key>optionC</key>
		<string> They can be compiled. </string>
		<key>optionD</key>
		<string> Complex methods can be described using javadoc.
</string>
		<key>question</key>
		<string>108.  How are skeletal class files useful for design specification? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>109</string>
		<key>identifier</key>
		<string>109</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only </string>
		<key>optionB</key>
		<string> I and II only </string>
		<key>optionC</key>
		<string> III only </string>
		<key>optionD</key>
		<string> I, II, and III  
</string>
		<key>question</key>
		<string>109.  During a design review, which of the following issues concerning the detailed design is (are) considered? 
Are all the accessor methods defined? 
Does the architecture support a low degree of coupling? 
Are the algorithm descriptions complete and unambiguous? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>110</string>
		<key>identifier</key>
		<string>110</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> I, II, and III only </string>
		<key>optionC</key>
		<string> III only </string>
		<key>optionD</key>
		<string> I and III only
</string>
		<key>question</key>
		<string>110.  The goals of design testing include which of the following? 
Compiling code for Java classes 
Analyzing data flow diagrams 
Verifying that a design incorporates system requirements 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>111</string>
		<key>identifier</key>
		<string>111</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> I and III only </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> I, II, and III 
</string>
		<key>question</key>
		<string>111.  Sequence diagrams include representations of which of the following? 
The user and external agents 
All objects in the system 
Messages passed between objects 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>112</string>
		<key>identifier</key>
		<string>112</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only </string>
		<key>optionB</key>
		<string> none </string>
		<key>optionC</key>
		<string> I and II </string>
		<key>optionD</key>
		<string> II only 
</string>
		<key>question</key>
		<string>112.  For an object calling another object, a message is associated with which of the objects in responsibility-driven design? 
The calling object /////////////////////////The called object 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>113</string>
		<key>identifier</key>
		<string>113</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> I only </string>
		<key>optionC</key>
		<string> I and III only </string>
		<key>optionD</key>
		<string> I, II, and III
</string>
		<key>question</key>
		<string>113.  Which of the following is true where a client-object diagram contains more than one top-level client object? 
It may be necessary to add a single top-level client object 
The implementation program may have multiple entry points 
The implementation program may not be portable to Java 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>114</string>
		<key>identifier</key>
		<string>114</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> I and III only </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> I, II, and III 
</string>
		<key>question</key>
		<string>114.  A good architectural design of a software system promotes which of the following? 
Understandability 
Optimal run-time performance 
Faster debugging 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>115</string>
		<key>identifier</key>
		<string>115</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> I only </string>
		<key>optionC</key>
		<string> II and III only </string>
		<key>optionD</key>
		<string> I and III only   
</string>
		<key>question</key>
		<string>115.  Data flow analysis includes which of the following? 
Creating a data flow diagram 
Finding the point of highest abstraction of the input 
Identifying the analysis and dispatch modules 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>116</string>
		<key>identifier</key>
		<string>116</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> coupling between objects </string>
		<key>optionB</key>
		<string> the chronological ordering of messages
 </string>
		<key>optionC</key>
		<string> the boundary between external agents and system objects
 </string>
		<key>optionD</key>
		<string> client-object relations 
</string>
		<key>question</key>
		<string>116.  Collaboration diagrams emphasize 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>117</string>
		<key>identifier</key>
		<string>117</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> receives a message from another object </string>
		<key>optionB</key>
		<string> is not invoked by any other objects
 </string>
		<key>optionC</key>
		<string> sends a message to another object </string>
		<key>optionD</key>
		<string> appears in a client-object diagram 
</string>
		<key>question</key>
		<string>117.  A client object is one that 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>118</string>
		<key>identifier</key>
		<string>118</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only </string>
		<key>optionB</key>
		<string> I and II only </string>
		<key>optionC</key>
		<string> II only </string>
		<key>optionD</key>
		<string> II and III onl
</string>
		<key>question</key>
		<string>118.  In data-oriented design, the architecture of the system is based on which of the following? 
A data flow diagram /////////////The structure of the data ///////The actions operating on the data 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>119</string>
		<key>identifier</key>
		<string>119</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> fourth </string>
		<key>optionB</key>
		<string> second </string>
		<key>optionC</key>
		<string> first </string>
		<key>optionD</key>
		<string> third  
</string>
		<key>question</key>
		<string>119.  The languages Fortran, Pascal, COBOL, and C++ are examples of which generation of programming languages? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>120</string>
		<key>identifier</key>
		<string>120</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It does not exist. </string>
		<key>optionB</key>
		<string> It is the goal of every programmer.
 </string>
		<key>optionC</key>
		<string> It exists but is extremely rare. </string>
		<key>optionD</key>
		<string> It is very common
</string>
		<key>question</key>
		<string>120.  Which of the following is true about self-documenting code? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>121</string>
		<key>identifier</key>
		<string>121</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> each branch has been tested for all possible values of relevant input
 </string>
		<key>optionB</key>
		<string> each statement controlled by a branch has been executed at least once
 </string>
		<key>optionC</key>
		<string> each branch in the code has been executed at least once
 </string>
		<key>optionD</key>
		<string> each variable tested in the branch has a value 
</string>
		<key>question</key>
		<string>121.  Branch coverage testing consists of ensuring that 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>122</string>
		<key>identifier</key>
		<string>122</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> three to six people, including representatives from the current and future phases
 </string>
		<key>optionB</key>
		<string> three people, including representatives from the current and future phases
 </string>
		<key>optionC</key>
		<string> six people, including representatives from the current phase and the client
 </string>
		<key>optionD</key>
		<string> four people, including a moderator, a designer, an implementer, and a tester 
</string>
		<key>question</key>
		<string>122.  In nonexecution-based testing of software, the inspections team consists of 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>123</string>
		<key>identifier</key>
		<string>123</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> used before and after nonexecution-based testing
 </string>
		<key>optionB</key>
		<string> used only after nonexecution-based testing </string>
		<key>optionC</key>
		<string> used before nonexecution-based testing
 </string>
		<key>optionD</key>
		<string> not use
</string>
		<key>question</key>
		<string>123.  In the Cleanroom technique, execution-based testing is 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>124</string>
		<key>identifier</key>
		<string>124</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> II and III only </string>
		<key>optionD</key>
		<string> I only 
</string>
		<key>question</key>
		<string>124. The decisions that management will have to make regarding testing include which of the following? 
The kind of testing                 The amount and extent 
When and whether the results of testing are sufficient to call for recoding 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>125</string>
		<key>identifier</key>
		<string>125</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only </string>
		<key>optionB</key>
		<string> I and II only </string>
		<key>optionC</key>
		<string> II and III only </string>
		<key>optionD</key>
		<string> I, II, and III 
</string>
		<key>question</key>
		<string>125.  Responsibility-driven programming is better than defensive programming for which of the following reasons? 
It is easier to estimate the number of remaining faults in a product. 
It isolates in one place all the checks for the appropriateness of input for a given call. 
It is easier to verify the code using black-box techniques. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>126</string>
		<key>identifier</key>
		<string>126</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> I only
</string>
		<key>question</key>
		<string>126.  Installation testing is performed during which of the following kinds of testing? 
Acceptance testing ///////////////Product testing ///////////Module testing 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>127</string>
		<key>identifier</key>
		<string>127</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> CASE workbench </string>
		<key>optionB</key>
		<string> coding tool </string>
		<key>optionC</key>
		<string> build tool </string>
		<key>optionD</key>
		<string> version management tool
</string>
		<key>question</key>
		<string>127.  An online interface checker is an example of a 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>128</string>
		<key>identifier</key>
		<string>128</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> code </string>
		<key>optionB</key>
		<string> design </string>
		<key>optionC</key>
		<string> requirements </string>
		<key>optionD</key>
		<string> testing
</string>
		<key>question</key>
		<string>128.  Application frameworks and code frameworks are ways of reusing 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>129</string>
		<key>identifier</key>
		<string>129</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> III only 
</string>
		<key>question</key>
		<string>129.  In choosing a language for the final product, which of the following factors should be considered? 
Whether the language supports coincidental cohesion 
Whether the language supports informational cohesion 
Whether the language is object-oriented 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>130</string>
		<key>identifier</key>
		<string>130</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> using Boolean combinations 
</string>
		<key>optionB</key>
		<string> improving code layout
 </string>
		<key>optionC</key>
		<string> using more meaningful variable names 
</string>
		<key>optionD</key>
		<string> using other control structures
</string>
		<key>question</key>
		<string>130.  Nested if statements can be simplified by 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>131</string>
		<key>identifier</key>
		<string>131</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only </string>
		<key>optionB</key>
		<string> II only </string>
		<key>optionC</key>
		<string> III only </string>
		<key>optionD</key>
		<string> II and III only  
</string>
		<key>question</key>
		<string>131.  Consider implementing an algorithm for division and testing code with the values 2, 1, 0, -1, and -2. Which of the following techniques is (are) being applied? 
Statement coverage /////////////////Boundary value testing ///////////Equivalence testing 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>132</string>
		<key>identifier</key>
		<string>132</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> walkthroughs are more formal and have more steps
 </string>
		<key>optionB</key>
		<string> walkthroughs are more formal but have fewer steps
 </string>
		<key>optionC</key>
		<string> inspections are more formal but have fewer steps
 </string>
		<key>optionD</key>
		<string> inspections are more formal and have more steps
</string>
		<key>question</key>
		<string>132.  The primary difference between code inspections and code walkthroughs is that 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>133</string>
		<key>identifier</key>
		<string>133</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It is used to help determine how long to test in order to guarantee that the product's fault rate satisfies specification.
 </string>
		<key>optionB</key>
		<string> It is used to help determine how many test cases should be used for a module.
 </string>
		<key>optionC</key>
		<string> It is used to compute the order in which test cases should be tried for a module.
 </string>
		<key>optionD</key>
		<string> It is used to compute the number of faults in a module based on its complexity.
</string>
		<key>question</key>
		<string>133.   Reliability analysis is used for which of the following purposes? 
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>134</string>
		<key>identifier</key>
		<string>134</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only </string>
		<key>optionB</key>
		<string> I and II only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> II and III only 
</string>
		<key>question</key>
		<string>134.  Which of the following statements is (are) true of testing techniques? 
All techniques have some advantages and disadvantages. 
All techniques are more or less equally effective at finding interface faults. 
All techniques are more or less equally cost-effective. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>135</string>
		<key>identifier</key>
		<string>135</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> graphical-interface testing better than to non-graphical-interface testing
 </string>
		<key>optionB</key>
		<string> object-oriented systems but not to non-object-oriented systems
 </string>
		<key>optionC</key>
		<string> both object-oriented and non-object-oriented systems
 </string>
		<key>optionD</key>
		<string> non-object-oriented systems but not to object-oriented systems
</string>
		<key>question</key>
		<string>135.  The strategies of top-down, bottom-up, and sandwich integration are suited to 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>136</string>
		<key>identifier</key>
		<string>136</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> I only </string>
		<key>optionC</key>
		<string> II and III only </string>
		<key>optionD</key>
		<string> I, II, and III  
</string>
		<key>question</key>
		<string>136.  In general, reliability testing of a software product checks which of the following? 
The frequency of failures ///////////The severity of failures ////////The location of failures 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>137</string>
		<key>identifier</key>
		<string>137</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Team process integration </string>
		<key>optionB</key>
		<string> User process integration </string>
		<key>optionC</key>
		<string> Process integration
 </string>
		<key>optionD</key>
		<string> Management process integration
</string>
		<key>question</key>
		<string>137.  Which of the following kinds of integration is associated with an environment that supports a specific software process? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>138</string>
		<key>identifier</key>
		<string>138</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> please managers  </string>
		<key>optionB</key>
		<string> improve readability
 </string>
		<key>optionC</key>
		<string> conform to standards  </string>
		<key>optionD</key>
		<string> help the SQA team 
</string>
		<key>question</key>
		<string>138.  The primary purpose of careful code layout is to 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>139</string>
		<key>identifier</key>
		<string>139</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> black-box testing, white-box testing
 </string>
		<key>optionB</key>
		<string> glass-box testing, black-box testing
 </string>
		<key>optionC</key>
		<string> black-box testing, black-box testing
 </string>
		<key>optionD</key>
		<string> white-box testing, white-box testing 
</string>
		<key>question</key>
		<string>139b139.  Structural testing is _____ and structured testing is _____. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>140</string>
		<key>identifier</key>
		<string>140</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> III only 
</string>
		<key>question</key>
		<string>140.  Nonexecution-based testing techniques can be applied to which of the following? 
Specifications //////////Design documents /////////Code modules 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>141</string>
		<key>identifier</key>
		<string>141</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> a logical deduction of the output of a piece of code for specific argument values
 </string>
		<key>optionB</key>
		<string> a mathematical proof that some code satisfies its specifications
 </string>
		<key>optionC</key>
		<string> an outdated method of testing code
 </string>
		<key>optionD</key>
		<string> the formal proof of the correctness of a theorem
</string>
		<key>question</key>
		<string>141.  In the context of software development, a correctness proof is 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>142</string>
		<key>identifier</key>
		<string>142</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> I only </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> I, II, and III
</string>
		<key>question</key>
		<string>142.  The decisions that management will have to make regarding testing include which of the following? 
The kind of testing /////////////The amount and extent
When and whether the results of testing are sufficient to call for recoding 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>143</string>
		<key>identifier</key>
		<string>143</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>143.  Which of the following is true when a sandwich integration strategy is applied to integration testing? 
Logic modules are implemented and integrated top-down. 
Operations modules are implemented and integrated bottom-up. 
Integration between the two groups is performed throughout the process. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>144</string>
		<key>identifier</key>
		<string>144</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> can be installed on the client's hardware </string>
		<key>optionB</key>
		<string> works with the developer's other software
 </string>
		<key>optionC</key>
		<string> works on the client's hardware </string>
		<key>optionD</key>
		<string> works with the client's other software 
</string>
		<key>question</key>
		<string>144. Installation testing of a software product checks to verify that it 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>145</string>
		<key>identifier</key>
		<string>145</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Software production by a large team, either at the module level or at the code level
 </string>
		<key>optionB</key>
		<string> Software development in general
 </string>
		<key>optionC</key>
		<string> Collaborative software development across multiple organizations
 </string>
		<key>optionD</key>
		<string> Software development at the module level, including architectural design
</string>
		<key>question</key>
		<string>145.  Programming-in-the-large refers to which of the following? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>146</string>
		<key>identifier</key>
		<string>146</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> the integration and maintenance, documentation
 </string>
		<key>optionB</key>
		<string> the requirements and specification, specifications </string>
		<key>optionC</key>
		<string> all, module
 </string>
		<key>optionD</key>
		<string> the design and implementation, code 
</string>
		<key>question</key>
		<string>146.  It is possible to reuse components from _____ phases of the software process, but _____ reuse is most common. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>147</string>
		<key>identifier</key>
		<string>147</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> first-generation languages, consist of zeros and ones
 </string>
		<key>optionB</key>
		<string> second-generation languages, reflect the architecture of the processor
 </string>
		<key>optionC</key>
		<string> interpreted languages, are good for prototyping
 </string>
		<key>optionD</key>
		<string> third-generation languages, provide abstract flow of control structures
</string>
		<key>question</key>
		<string>147.  Assembly languages are also called _____ and they_____. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>148</string>
		<key>identifier</key>
		<string>148</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> check with the manager to determine whether the code can stand as is
 </string>
		<key>optionB</key>
		<string> keep the code in violation and hide the fact
 </string>
		<key>optionC</key>
		<string> rewrite the code to meet standards
 </string>
		<key>optionD</key>
		<string> argue that the standards do not apply to every kind of code 
</string>
		<key>question</key>
		<string>148.  If a decision by a programmer results in a violation of coding standards, the programmer should 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>149</string>
		<key>identifier</key>
		<string>149</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> programmer of the module </string>
		<key>optionB</key>
		<string> implementation team </string>
		<key>optionC</key>
		<string> end users
 </string>
		<key>optionD</key>
		<string> developer's SQA group 
</string>
		<key>question</key>
		<string>149.  The ultimate responsibility for verifying the correctness of modules rests with the 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>150</string>
		<key>identifier</key>
		<string>150</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> checklist of faults
 </string>
		<key>optionB</key>
		<string> number of faults found by each team member
 </string>
		<key>optionC</key>
		<string> number of faults found, ranked by severity
 </string>
		<key>optionD</key>
		<string> number of lines of code containing faults
</string>
		<key>question</key>
		<string>150.  In nonexecution-based testing of software, an important product of the inspections process is the 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>151</string>
		<key>identifier</key>
		<string>151</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only </string>
		<key>optionB</key>
		<string> I only </string>
		<key>optionC</key>
		<string> I and III only </string>
		<key>optionD</key>
		<string> II and III only
</string>
		<key>question</key>
		<string>151.  Which of the following statements is (are) true of correctness proofs? 
They are suitable for all products. 
Their cost-effectiveness depends on the product. 
They require skills that only logicians have. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>152</string>
		<key>identifier</key>
		<string>152</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III </string>
		<key>optionB</key>
		<string> I only </string>
		<key>optionC</key>
		<string> III only </string>
		<key>optionD</key>
		<string> II and III only 
</string>
		<key>question</key>
		<string>152. h of the following are disadvantages of top-down integration testing of software? 
Operational modules may not be adequately tested. 
It will make the testing process more complex. 
It promotes responsibility-driven design. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>153</string>
		<key>identifier</key>
		<string>153</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only </string>
		<key>optionB</key>
		<string> I only </string>
		<key>optionC</key>
		<string> II only </string>
		<key>optionD</key>
		<string> III only
</string>
		<key>question</key>
		<string>153. h of the following is (are) true about a build tool for software development? 
It should be used in conjunction with a configuration management tool. 
It helps compile, link, and execute a complex software product during testing. 
It helps in selecting and assembling the correct version of code modules. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>154</string>
		<key>identifier</key>
		<string>154</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> how quickly development can be accomplished with that language
 </string>
		<key>optionB</key>
		<string> how well known the language is
 </string>
		<key>optionC</key>
		<string> whether the language is fourth-generation
 </string>
		<key>optionD</key>
		<string> whether the language is interpreted 
</string>
		<key>question</key>
		<string>154. main criterion for choosing a language for rapid prototyping should be 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>155</string>
		<key>identifier</key>
		<string>155</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Documenting every line of code
 </string>
		<key>optionB</key>
		<string> Making certain that procedures are shorter than ten lines
 </string>
		<key>optionC</key>
		<string> Making variable names meaningful to persons other than the code's author
 </string>
		<key>optionD</key>
		<string> Using named constants wherever possible 
</string>
		<key>question</key>
		<string>155. he following coding style practices, which best facilitates future maintenance? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>156</string>
		<key>identifier</key>
		<string>156</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> one hour </string>
		<key>optionB</key>
		<string> two hours </string>
		<key>optionC</key>
		<string> three hours </string>
		<key>optionD</key>
		<string> four hours
</string>
		<key>question</key>
		<string>156.  time limit on an effective walkthrough or code-review session is 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>157</string>
		<key>identifier</key>
		<string>157</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> II only </string>
		<key>optionD</key>
		<string> I, II, and II 
</string>
		<key>question</key>
		<string>157.  Which of the following techniques create fault statistics? 
Nonexecution-based testing techniques 
Glass-box-based testing techniques 
Black-box testing techniques 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>158</string>
		<key>identifier</key>
		<string>158</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> assertions are placed in the called module
 </string>
		<key>optionB</key>
		<string> both calling and called modules check for the appropriateness of an input to the called module
 </string>
		<key>optionC</key>
		<string> the called module checks input to ensure that it has not been called with inappropriate input
 </string>
		<key>optionD</key>
		<string> the calling module checks input to the called module to ensure that the input is appropriate 
</string>
		<key>question</key>
		<string>158.  responsibility-driven programming 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>159</string>
		<key>identifier</key>
		<string>159</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> I and II </string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>159.  During product testing, which of the following techniques should be used to verify that the product satisfies its output specifications? 
Glass-box techniques 
Black-box techniques 
Nonexecution-based techniques 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>160</string>
		<key>identifier</key>
		<string>160</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Requirements and specification
 </string>
		<key>optionB</key>
		<string> Implementation, integration, and maintenance
 </string>
		<key>optionC</key>
		<string> Design, implementation, and integration
 </string>
		<key>optionD</key>
		<string> Requirements, specification, and design 
</string>
		<key>question</key>
		<string>160.  A front-end CASE tool (upperCASE tool) is one that assists with which phases of software development? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>161</string>
		<key>identifier</key>
		<string>161</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> III only </string>
		<key>optionD</key>
		<string> II and III only
</string>
		<key>question</key>
		<string>161.  In which of the following places should the interface to a module be documented? 
The testing document 
A separate document containing general documentation for the system 
The prologue of each module 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>162</string>
		<key>identifier</key>
		<string>162</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> I only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> II and III only 
</string>
		<key>question</key>
		<string>162.  Which of the following should be present in a module prologue? 
Module input/output 
The names of files accessed and changed by the module 
The name of the file or files containing test data for the module 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>163</string>
		<key>identifier</key>
		<string>163</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> All major functionalities of the system in complete detail for each topic
 </string>
		<key>optionB</key>
		<string> A few common scenarios of use, introduced in order of complexity
 </string>
		<key>optionC</key>
		<string> The most commonly used functionality of the system
 </string>
		<key>optionD</key>
		<string> All major functionalities of the system with a gradual introduction of detail  
</string>
		<key>question</key>
		<string>163.  User training materials should cover which of the following? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>164</string>
		<key>identifier</key>
		<string>164</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> User's reference manual </string>
		<key>optionB</key>
		<string> Installer/administrator documentation
 </string>
		<key>optionC</key>
		<string> Maintainer's manual </string>
		<key>optionD</key>
		<string> User training manual  
</string>
		<key>question</key>
		<string>164.  Instructions for both the installation of the product and procedures for initialization are included in which of the following? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>165</string>
		<key>identifier</key>
		<string>165</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> User reference manual </string>
		<key>optionB</key>
		<string> Maintainer's documentation
 </string>
		<key>optionC</key>
		<string> User quick reference </string>
		<key>optionD</key>
		<string> User training materials  
</string>
		<key>question</key>
		<string>165.  A complete and detailed description of the functionality available in a software product is found in the 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>166</string>
		<key>identifier</key>
		<string>166</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The developer </string>
		<key>optionB</key>
		<string> The client </string>
		<key>optionC</key>
		<string> The programmers </string>
		<key>optionD</key>
		<string> The maintainers
</string>
		<key>question</key>
		<string>166.  Which of the following typically takes the responsibility of emphasizing the priority of allocating proper resources to the documentation of a software product? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>167</string>
		<key>identifier</key>
		<string>167</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> I and III only </string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>167.   thorough documentation process emphasizes that 
Documentation will be produced throughout the life cycle and kept up to date 
Documents for each phase will be completed by people who participated in that phase 
Documentation will lag behind the product by no more than one version 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>168</string>
		<key>identifier</key>
		<string>168</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> I only 
</string>
		<key>question</key>
		<string>168.  Which of the following is (are) true about documentation standards for software products? 
They should be established before or during the planning process. 
They should be incorporated into the software project management plan. 
They should be approved by the client. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>169</string>
		<key>identifier</key>
		<string>169</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> I onl
</string>
		<key>question</key>
		<string>169.  To make the process of developing and maintaining documentation for a software product as efficient as possible, the developer's organization should use which of the following? 
CASE tools 
Stringent penalties for poor documentation 
Documentation standards 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>170</string>
		<key>identifier</key>
		<string>170</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> II only </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> I, II, and III
</string>
		<key>question</key>
		<string>170.  Which of the following should be present in a module prologue? 
Error-handling capabilities 
A list of modifications made, by whom, on what date, and approved by whom 
Known faults of the module 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>171</string>
		<key>identifier</key>
		<string>171</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only </string>
		<key>optionB</key>
		<string> I and III only </string>
		<key>optionC</key>
		<string> I only </string>
		<key>optionD</key>
		<string> I, II, and III 
</string>
		<key>question</key>
		<string>171.  Which of the following is (are) part of inline documentation? 
Comments explaining procedures, functions, and methods 
Documentation of data flow among modules 
Documentation of variables 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>172</string>
		<key>identifier</key>
		<string>172</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only </string>
		<key>optionB</key>
		<string> II only </string>
		<key>optionC</key>
		<string> I and III only </string>
		<key>optionD</key>
		<string> I, II, and III 
</string>
		<key>question</key>
		<string>172.  Which of the following is (are) among the possible contents of the user quick reference for a software product? 
Brief descriptions of commands and arguments 
A list of the most common operations by topic 
Pointers to the user's reference manual 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>173</string>
		<key>identifier</key>
		<string>173</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only </string>
		<key>optionB</key>
		<string> I and III only </string>
		<key>optionC</key>
		<string> II and III only </string>
		<key>optionD</key>
		<string> I, II, and III  
</string>
		<key>question</key>
		<string>173.  Which of the following are possible documents that could be included in the maintainer's documentation? 
Retirement documents /////Specifications and design documents ///Testing documents 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>174</string>
		<key>identifier</key>
		<string>174</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> II only </string>
		<key>optionD</key>
		<string> I and III only
</string>
		<key>question</key>
		<string>174.  Which of the following are valid approaches when creating training materials for the first-time or novice end users of a software product? 
Discussing the use of the system in general 
Presenting different scenarios of use 
Giving examples of uses and problems with solutions 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>175</string>
		<key>identifier</key>
		<string>175</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only </string>
		<key>optionB</key>
		<string> II only </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> I, II, and III 
</string>
		<key>question</key>
		<string>175. The reasons for documenting software development as early and completely as possible include which of the following? 
If postponed, the documentation may never be completed. 
If postponed, the staff who worked on earlier phases may no longer be available. 
If postponed, any design changes made during implementation will be difficult to document. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>176</string>
		<key>identifier</key>
		<string>176</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> III only </string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>176.  Which of the following is (are) true of maintaining uniformity in documentation for a software product? 
It helps the management of the developer's organization track progress. 
It aids the SQA group in performing their job. 
It helps nonexpert computer users understand the software. 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>177</string>
		<key>identifier</key>
		<string>177</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only </string>
		<key>optionB</key>
		<string> II only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> II and III only
</string>
		<key>question</key>
		<string>177.  CASE tools can help the documentation process for a software product in which of the following ways? 
By reducing the drudgery associated with documentation upkeep 
By making the documentation available online for searching and changing 
By centralizing and distributing changes to documentation 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>178</string>
		<key>identifier</key>
		<string>178</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III </string>
		<key>optionB</key>
		<string> I and II only </string>
		<key>optionC</key>
		<string> I only </string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>178.  The documentation that must be prepared before delivering a software product to a client includes which of the following? 
Maintainer's documentation 
Installer/administrator documentation 
Future enhancements documentation 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>179</string>
		<key>identifier</key>
		<string>179</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It is poorly paid and is not well regarded by management.
 </string>
		<key>optionB</key>
		<string> It is an activity that is looked down upon by other programmers.
 </string>
		<key>optionC</key>
		<string> No matter how good the documentation is, finding faults is difficult.
 </string>
		<key>optionD</key>
		<string> It incorporates aspects of all other phases of development.
</string>
		<key>question</key>
		<string>179.  Software maintenance is difficult for which of the following reasons? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>180</string>
		<key>identifier</key>
		<string>180</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> incompletely specified software products
 </string>
		<key>optionB</key>
		<string> imperfectly designed software products
 </string>
		<key>optionC</key>
		<string> almost all software products
 </string>
		<key>optionD</key>
		<string> badly implemented software products 
</string>
		<key>question</key>
		<string>180.  Maintenance is normally required in 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>181</string>
		<key>identifier</key>
		<string>181</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Changes made after it has passed the acceptance test
 </string>
		<key>optionB</key>
		<string> Changes made to improve its performance on the job
 </string>
		<key>optionC</key>
		<string> Changes made to fix remaining faults
 </string>
		<key>optionD</key>
		<string> Changes made to extend its functionality  
</string>
		<key>question</key>
		<string>181.  Which of the following kinds of changes to a software product characterizes maintenance of the product? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>182</string>
		<key>identifier</key>
		<string>182</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> a workaround
 </string>
		<key>optionB</key>
		<string> workflow management
 </string>
		<key>optionC</key>
		<string> regression priority
 </string>
		<key>optionD</key>
		<string> fault prioritization  
</string>
		<key>question</key>
		<string>182.  A way of minimizing the impact of a software fault that is too expensive or time consuming to fix is to use 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>183</string>
		<key>identifier</key>
		<string>183</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> They should not be reported until there is test data available for analysis.
 </string>
		<key>optionB</key>
		<string> They should be reported only if at least three different users encounter the fault.
 </string>
		<key>optionC</key>
		<string> They should be reported only if they are serious enough to affect user productivity.
 </string>
		<key>optionD</key>
		<string> They should be reported even without test data.
</string>
		<key>question</key>
		<string>183.  How should nonrepeatable faults that occur sporadically be handled? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>184</string>
		<key>identifier</key>
		<string>184</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> II only </string>
		<key>optionD</key>
		<string> I only 
</string>
		<key>question</key>
		<string>184.  Which of the following statements is (are) applicable to a situation where the client keeps wanting changes made after the product is delivered? 
Satisfaction of the client is very important. 
The developer can inform the client about the cost of repeated maintenance. 
The developer may need to have the product rewritten from scratch when maintenance becomes hazardous. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>185</string>
		<key>identifier</key>
		<string>185</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III </string>
		<key>optionB</key>
		<string> III only </string>
		<key>optionC</key>
		<string> II only </string>
		<key>optionD</key>
		<string> I and III only 
</string>
		<key>question</key>
		<string>185.  The fragile-class problem comes about because of which of the following? 
Encapsulation ///////////Polymorphism ///////Inheritance 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>186</string>
		<key>identifier</key>
		<string>186</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> information hiding and inheritance
 </string>
		<key>optionB</key>
		<string> encapsulation and information hiding
 </string>
		<key>optionC</key>
		<string> encapsulation and inheritance
 </string>
		<key>optionD</key>
		<string> polymorphism and dynamic binding 
</string>
		<key>question</key>
		<string>186.  Two properties of object-oriented software that make it easier to maintain are 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>187</string>
		<key>identifier</key>
		<string>187</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only </string>
		<key>optionB</key>
		<string> I and II </string>
		<key>optionC</key>
		<string> none </string>
		<key>optionD</key>
		<string> II only 
</string>
		<key>question</key>
		<string>187.  The metrics that are useful during the maintenance phase of software development include which of the following? 
Metrics used during previous phases 
Metrics that track fault reports 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>188</string>
		<key>identifier</key>
		<string>188</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> usually responding to the client's request to minimize the cost of maintenance
 </string>
		<key>optionB</key>
		<string> making a well-thought-out judgment concerning distribution of staff
 </string>
		<key>optionC</key>
		<string> perpetuating the bad reputation of maintenance programming
 </string>
		<key>optionD</key>
		<string> making an economically sound decision  
</string>
		<key>question</key>
		<string>188.  By assigning less skilled programmers to maintenance, management is 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>189</string>
		<key>identifier</key>
		<string>189</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> improving the product without changing its functionality
 </string>
		<key>optionB</key>
		<string> changing the architectural design while reusing the implemented code
 </string>
		<key>optionC</key>
		<string> developing the product from its specifications to implementation
 </string>
		<key>optionD</key>
		<string> redoing the detailed design but not the architectural design 
</string>
		<key>question</key>
		<string>189.  Restructuring is the process of 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>190</string>
		<key>identifier</key>
		<string>190</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> harder because the type of values may change at run time
 </string>
		<key>optionB</key>
		<string> harder because definitions may be spread out all over the code
 </string>
		<key>optionC</key>
		<string> easier because code is reused and does not need retesting
 </string>
		<key>optionD</key>
		<string> easier because code is localized    
</string>
		<key>question</key>
		<string>190.  Inheritance in object-oriented systems makes maintenance 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>191</string>
		<key>identifier</key>
		<string>191</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only </string>
		<key>optionB</key>
		<string> I and III only </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> I, II, and III 
</string>
		<key>question</key>
		<string>191.  Useful metrics for tracking fault reports include which of the following? 
A classification of faults reported 
The status of fault reports 
The number of faults reported during specific periods and in total 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>192</string>
		<key>identifier</key>
		<string>192</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II </string>
		<key>optionB</key>
		<string> none </string>
		<key>optionC</key>
		<string> I only </string>
		<key>optionD</key>
		<string> II only 
</string>
		<key>question</key>
		<string>192.  Which of the following is (are) true about perfective maintenance of a software product? 
It enhances the product with respect to performance and functionality. 
It is made necessary by changing conditions in the client's environment. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>193</string>
		<key>identifier</key>
		<string>193</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> III only </string>
		<key>optionC</key>
		<string> I and III only </string>
		<key>optionD</key>
		<string> I, II, and III  
</string>
		<key>question</key>
		<string>193.  Which of the following is (are) true of maintenance of a software product? 
It is perceived as a low-glamour activity by programmers. 
It is often paid less than is programming from scratch. 
It is very difficult because software is so often documented poorly. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>194</string>
		<key>identifier</key>
		<string>194</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> III only
</string>
		<key>question</key>
		<string>194.  Which of the following are types of maintenance? 
Corrective maintenance 
Preventive maintenance 
Adaptive maintenance 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>195</string>
		<key>identifier</key>
		<string>195</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> III only  
</string>
		<key>question</key>
		<string>195.  Problem reporting systems can help manage the workflow of software maintenance by which of the following? 
Providing a central repository of faults and information about them 
Storing test cases for scheduled fault fixes 
Making it impossible for faults to be forgotten 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>196</string>
		<key>identifier</key>
		<string>196</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> be given low priority but eventually be fixed
 </string>
		<key>optionB</key>
		<string> be fixed only when there is enough money in the budget to cover fixing such faults
 </string>
		<key>optionC</key>
		<string> be fixed only if the client makes a special request
 </string>
		<key>optionD</key>
		<string> not be fixed 
</string>
		<key>question</key>
		<string>196.  A software fault that occurs rarely, has low user productivity impact, and is expensive to fix should 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>197</string>
		<key>identifier</key>
		<string>197</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> maintenance testing </string>
		<key>optionB</key>
		<string> acceptance testing </string>
		<key>optionC</key>
		<string> regression testing
 </string>
		<key>optionD</key>
		<string> change testing  
</string>
		<key>question</key>
		<string>197.  After a product has undergone changes during maintenance, the process of testing that the changes have not negatively impacted other functionality is called 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>198</string>
		<key>identifier</key>
		<string>198</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III </string>
		<key>optionB</key>
		<string> I and II only </string>
		<key>optionC</key>
		<string> I only </string>
		<key>optionD</key>
		<string> III only   
</string>
		<key>question</key>
		<string>198.  Which of the following is (are) true about a product when it is undergoing updates during maintenance? 
The previous version should be frozen as a baseline. 
The revisions should be treated as branches from the baseline. 
The modules can be released back into the pool before rigorous testing. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>199</string>
		<key>identifier</key>
		<string>199</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only </string>
		<key>optionB</key>
		<string> I and II only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> II and III only 
</string>
		<key>question</key>
		<string>199.  Criteria used for prioritizing software faults include which of the following? 
Frequency of occurrence 
Estimated effort to diagnose and fix 
Impact on user productivity 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>200</string>
		<key>identifier</key>
		<string>200</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It is the same as maintenance for non-object-oriented software.
 </string>
		<key>optionB</key>
		<string> It has its own challenges, even though it is easier in some ways than maintenance for non-object-oriented software.
 </string>
		<key>optionC</key>
		<string> It is always easier than maintenance for non-objected-oriented software.
 </string>
		<key>optionD</key>
		<string> It is generally more difficult than maintenance for non-object-oriented software.
</string>
		<key>question</key>
		<string>200.  Which of the following is true about maintenance for object-oriented software? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>201</string>
		<key>identifier</key>
		<string>201</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> perfective maintenance
 </string>
		<key>optionB</key>
		<string> adaptive maintenance
 </string>
		<key>optionC</key>
		<string> after-the-fact maintenance
 </string>
		<key>optionD</key>
		<string> corrective maintenance
</string>
		<key>question</key>
		<string>201.  Maintenance activities that remove residual faults in the software product are called 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>202</string>
		<key>identifier</key>
		<string>202</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> II only  
</string>
		<key>question</key>
		<string>202.  Which of the following activities may be performed during maintenance? 
Determining whether the fault reported is really a software problem 
Locating the source of the fault in the code and fixing it 
Testing the fixes and updating the documentation   
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>203</string>
		<key>identifier</key>
		<string>203</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> reengineering
 </string>
		<key>optionB</key>
		<string> reverse engineering
 </string>
		<key>optionC</key>
		<string> backward engineering
 </string>
		<key>optionD</key>
		<string> forward engineering 
</string>
		<key>question</key>
		<string>203.  When the only documentation available for a software code is the code itself, the process of reconstructing the design and specifications is called 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>204</string>
		<key>identifier</key>
		<string>204</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> identify the data objects used by the system
 </string>
		<key>optionB</key>
		<string> identify the actions that will affect the system's data
 </string>
		<key>optionC</key>
		<string> determine the sequence of the system's actions
 </string>
		<key>optionD</key>
		<string> determine the structure of the system's actions  
</string>
		<key>question</key>
		<string>204.  The primary role of the data flow diagram is to 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>205</string>
		<key>identifier</key>
		<string>205</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> extract candidate objects from the use case scenarios
 </string>
		<key>optionB</key>
		<string> create an object diagram in UML
 </string>
		<key>optionC</key>
		<string> create and refine the preliminary class list
 </string>
		<key>optionD</key>
		<string> specify the classes along with their attributes and methods
</string>
		<key>question</key>
		<string>205.  In object-oriented analysis, the first step of the class-modeling phase is to 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>206</string>
		<key>identifier</key>
		<string>225</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only </string>
		<key>optionB</key>
		<string> III only </string>
		<key>optionC</key>
		<string> I, II, and III </string>
		<key>optionD</key>
		<string> II and III only
</string>
		<key>question</key>
		<string>225.  Impediments to functional testing of even a moderate size program include which of the following? 
Functions are usually too numerous for systematic testing. 
Functions are usually intertwined and hard to test individually. 
Functionality often spans across module boundaries.   
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>207</string>
		<key>identifier</key>
		<string>330</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> third </string>
		<key>optionB</key>
		<string> first </string>
		<key>optionC</key>
		<string> second </string>
		<key>optionD</key>
		<string> fourth 
</string>
		<key>question</key>
		<string>330. The languages Fortran, Pascal, COBOL, and C++ are examples of which generation of programming languages?
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>208</string>
		<key>identifier</key>
		<string>331</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> for values that will never change </string>
		<key>optionB</key>
		<string> as much as possible
 </string>
		<key>optionC</key>
		<string> for values that will probably not change
 </string>
		<key>optionD</key>
		<string> for values that will seldom change  
</string>
		<key>question</key>
		<string>331. Constants should be used 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>209</string>
		<key>identifier</key>
		<string>332</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only </string>
		<key>optionB</key>
		<string> I only </string>
		<key>optionC</key>
		<string> none </string>
		<key>optionD</key>
		<string> I and II  
</string>
		<key>question</key>
		<string>332.  Impediments to structural testing in even a moderate size program include which of the following? 
It is not possible to test each path 
It is not possible to test each choice point with the data that will show a fault 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>210</string>
		<key>identifier</key>
		<string>333</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> I and III only </string>
		<key>optionD</key>
		<string> II and III only 
</string>
		<key>question</key>
		<string>333. In nonexecution-based testing of software, the inspections team includes which of the following roles? 
The moderator ////////////The client representative/////////The recorder    
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>211</string>
		<key>identifier</key>
		<string>334</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> need attention </string>
		<key>optionB</key>
		<string> to recode in order to decrease complexity
 </string>
		<key>optionC</key>
		<string> have more faults </string>
		<key>optionD</key>
		<string> should be tested by the SQA group
</string>
		<key>question</key>
		<string>334. The primary use of complexity metrics is to determine which modules 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>212</string>
		<key>identifier</key>
		<string>335</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> I and III only </string>
		<key>optionD</key>
		<string> II and III only 
</string>
		<key>question</key>
		<string>335. Which of the following statements is (are) true of testing techniques? 
All techniques have some advantages and disadvantages. 
All techniques are more or less equally effective at finding interface faults. 
All techniques are more or less equally cost-effective.
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>213</string>
		<key>identifier</key>
		<string>336</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only </string>
		<key>optionB</key>
		<string> I and II only </string>
		<key>optionC</key>
		<string> III only </string>
		<key>optionD</key>
		<string> I, II, and III
</string>
		<key>question</key>
		<string>336. Which of the following are advantages of bottom-up integration? 
It highlights design and coding faults early on. 
It helps isolate faults to the upper modules. 
It results in thorough testing of the operations models.
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>214</string>
		<key>identifier</key>
		<string>337</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III </string>
		<key>optionB</key>
		<string> II and III only </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> II only
</string>
		<key>question</key>
		<string>337. Utility of a software product includes which of the following? 
The ease with which a product can be used 
The usefulness of the product 
The cost-effectiveness of the product relative to competing products 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>215</string>
		<key>identifier</key>
		<string>338</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> To maintain different versions of the system
 </string>
		<key>optionB</key>
		<string> To keep management informed of the progress on various components of the product
 </string>
		<key>optionC</key>
		<string> To help integration testing be performed smoothly and quickly
 </string>
		<key>optionD</key>
		<string> To keep programmers from changing the same module(s) simultaneously 
</string>
		<key>question</key>
		<string>338.  Baselines and access control systems are used for what purpose?
</string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>216</string>
		<key>identifier</key>
		<string>339</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> none </string>
		<key>optionB</key>
		<string> I and II </string>
		<key>optionC</key>
		<string> II only </string>
		<key>optionD</key>
		<string> I only  
</string>
		<key>question</key>
		<string>339. In contract software, the issues that might limit reuse of code include which of the following? 
Legal ownership of the code 
The higher cost of planning for development 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>217</string>
		<key>identifier</key>
		<string>340</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> To transition into the final product with a minimum of recoding
 </string>
		<key>optionB</key>
		<string> As a substitute for design documents
 </string>
		<key>optionC</key>
		<string> As a substitute for specifications
 </string>
		<key>optionD</key>
		<string> Eliciting requirements from the user
</string>
		<key>question</key>
		<string>340.  Rapid prototyping should be used for what purpose? 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>218</string>
		<key>identifier</key>
		<string>341</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> incremental model </string>
		<key>optionB</key>
		<string> synchronize-and-stabilize model
 </string>
		<key>optionC</key>
		<string> fountain model </string>
		<key>optionD</key>
		<string> waterfall model 
</string>
		<key>question</key>
		<string>341.  An open modular architecture for software is a requirement of the 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>219</string>
		<key>identifier</key>
		<string>342</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only </string>
		<key>optionB</key>
		<string> I, II, and III </string>
		<key>optionC</key>
		<string> I and II only </string>
		<key>optionD</key>
		<string> II and III only 
</string>
		<key>question</key>
		<string>342.  Which of the following are updated after enhancements have been added to a software product?
Documentation for module interfacing 
Documentation of test cases 
The requirements, specification, and design documents 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>220</string>
		<key>identifier</key>
		<string>343</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II</string>
		<key>optionB</key>
		<string> none </string>
		<key>optionC</key>
		<string> II only </string>
		<key>optionD</key>
		<string> I only
</string>
		<key>question</key>
		<string>343. In object-oriented analysis, which of the following are given emphasis? 
Data ////////////////Actions 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>221</string>
		<key>identifier</key>
		<string>344</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> labeled oval </string>
		<key>optionB</key>
		<string> partitioned rectangle </string>
		<key>optionC</key>
		<string> labeled arrow
 </string>
		<key>optionD</key>
		<string> line labeled with cardinality information
</string>
		<key>question</key>
		<string>344.  In an object diagram, a class is represented as a 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>222</string>
		<key>identifier</key>
		<string>345</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It is purely action oriented. </string>
		<key>optionB</key>
		<string> It is purely data oriented.
 </string>
		<key>optionC</key>
		<string> It is both action and data oriented. </string>
		<key>optionD</key>
		<string> It is neither action nor data oriented. 
</string>
		<key>question</key>
		<string>345.  Which of the following is true of Dynamic Modeling in OOA? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>223</string>
		<key>identifier</key>
		<string>346</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Designed reuse </string>
		<key>optionB</key>
		<string> Accidental reuse </string>
		<key>optionC</key>
		<string> Purposeful reuse </string>
		<key>optionD</key>
		<string> Managed reuse
</string>
		<key>question</key>
		<string>346.  Which of the following is the term for reuse of code made possible because someone realized that the code of a previously developed component could be reused? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>224</string>
		<key>identifier</key>
		<string>347</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The module is discarded.
 </string>
		<key>optionB</key>
		<string> The programmer responsible is reprimanded.
 </string>
		<key>optionC</key>
		<string> The inspection team must reinspect the module fully after it has been reworked.
 </string>
		<key>optionD</key>
		<string> Similar modules are reinspected.
</string>
		<key>question</key>
		<string>347.Which of the following is true when an inspection finds that 5 percent or more of a module must be reworked? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>225</string>
		<key>identifier</key>
		<string>348</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> A module that has yet to be coded but passes the appropriate values to the module being tested
 </string>
		<key>optionB</key>
		<string> A special kind of module in an application
 </string>
		<key>optionC</key>
		<string> The module being tested
 </string>
		<key>optionD</key>
		<string> A module that either returns the information that was called or returns appropriate hard-coded values for given input
</string>
		<key>question</key>
		<string>348.In a software testing activity, a driver refers to which of the following? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>226</string>
		<key>identifier</key>
		<string>349</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only
 </string>
		<key>optionB</key>
		<string> I only
 </string>
		<key>optionC</key>
		<string> I, II, and III
 </string>
		<key>optionD</key>
		<string> I and II only  

</string>
		<key>question</key>
		<string>349.Product testing for contract software includes which of the following? 
Reliability testing 
Robustness testing 
Utility testing 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>227</string>
		<key>identifier</key>
		<string>350</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> force the programmer to observe them
 </string>
		<key>optionB</key>
		<string> respond in a way that balances the benefit of the standards with the burden they put on the programmer
 </string>
		<key>optionC</key>
		<string> discipline the programmer
 </string>
		<key>optionD</key>
		<string> have someone rewrite the code so it meets standards  
</string>
		<key>question</key>
		<string>350.If a programmer violates coding standards, the manager should 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>228</string>
		<key>identifier</key>
		<string>351</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The inspection team members disagree on the severity of the faults.
 </string>
		<key>optionB</key>
		<string> The programmer who coded the module thinks so.
 </string>
		<key>optionC</key>
		<string> The inspection team members are dissatisfied with the quality of the code.
 </string>
		<key>optionD</key>
		<string> Many more faults are found in that module than in any other module. 
</string>
		<key>question</key>
		<string>351.It may be worth redesigning and recoding a module from scratch under which of the following conditions? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>229</string>
		<key>identifier</key>
		<string>352</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only
 </string>
		<key>optionB</key>
		<string> I, II, and III
 </string>
		<key>optionC</key>
		<string> II and III only
 </string>
		<key>optionD</key>
		<string> III only 
</string>
		<key>question</key>
		<string>352.The manager of the SQA group should run integration testing because 
programmers may have seen inconsistent copies of the design documentation 
programmers may be unwilling to take blame for inconsistencies between modules 
the SQA group has the most to lose if testing is badly performed 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>230</string>
		<key>identifier</key>
		<string>353</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> inheritance and polymorphism make reused code easy to understand
 </string>
		<key>optionB</key>
		<string> small self-contained objects facilitate reuse, but other problems complicate it
 </string>
		<key>optionC</key>
		<string> small self-contained objects guarantee a high degree of reuse
 </string>
		<key>optionD</key>
		<string> code reuse is impossible  
</string>
		<key>question</key>
		<string>353.In object-oriented systems 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>231</string>
		<key>identifier</key>
		<string>354</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> by carefully examining the code for all external interfaces for the module
 </string>
		<key>optionB</key>
		<string> without examining any code
 </string>
		<key>optionC</key>
		<string> by wrapping the module to be tested in special black-box code
 </string>
		<key>optionD</key>
		<string> by carefully examining all critical parts of the code 
</string>
		<key>question</key>
		<string>354.Black-box testing techniques are so named because testing is performed 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>232</string>
		<key>identifier</key>
		<string>355</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
 </string>
		<key>optionB</key>
		<string> III only
 </string>
		<key>optionC</key>
		<string> I, II, and III
 </string>
		<key>optionD</key>
		<string> II only  
</string>
		<key>question</key>
		<string>355.Which of the following is (are) considered a validation activity? 
Product testing 
Acceptance testing 
Documentation testing 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>233</string>
		<key>identifier</key>
		<string>356</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II
 </string>
		<key>optionB</key>
		<string> none
 </string>
		<key>optionC</key>
		<string> I only
 </string>
		<key>optionD</key>
		<string> II only  
</string>
		<key>question</key>
		<string>356.Management integration refers to a CASE environment that supports which of the following? 
Management of the software development process 
Good communication at management-level meetings 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>234</string>
		<key>identifier</key>
		<string>357</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> specify the classes along with their attributes and methods
 </string>
		<key>optionB</key>
		<string> create and refine the preliminary class list
 </string>
		<key>optionC</key>
		<string> extract candidate objects from the use case scenarios
 </string>
		<key>optionD</key>
		<string> create an object diagram in UML  
</string>
		<key>question</key>
		<string>357.In object-oriented analysis, the second step of the class-modeling phase is to  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>235</string>
		<key>identifier</key>
		<string>358</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Changes in design brought about by changes in requirements during development
 </string>
		<key>optionB</key>
		<string> Changes in the client's computing facilities and environment
 </string>
		<key>optionC</key>
		<string> Novel and unpredicted requirements of the client's organization
 </string>
		<key>optionD</key>
		<string> Critiques levied by users during acceptance testing 
</string>
		<key>question</key>
		<string>358.Adaptive maintenance occurs in response to which of the following? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>236</string>
		<key>identifier</key>
		<string>359</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> third
 </string>
		<key>optionB</key>
		<string> first
 </string>
		<key>optionC</key>
		<string> second
 </string>
		<key>optionD</key>
		<string> fourth 
</string>
		<key>question</key>
		<string>359.The languages Fortran, Pascal, COBOL, and C++ are examples of which generation of programming languages? 
 

  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>237</string>
		<key>identifier</key>
		<string>360</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> for values that will never change
 </string>
		<key>optionB</key>
		<string> as much as possible
 </string>
		<key>optionC</key>
		<string> for values that will probably not change
 </string>
		<key>optionD</key>
		<string> for values that will seldom change
</string>
		<key>question</key>
		<string>360.Constants should be used 
 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>238</string>
		<key>identifier</key>
		<string>361</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only
 </string>
		<key>optionB</key>
		<string> I only
 </string>
		<key>optionC</key>
		<string> none
 </string>
		<key>optionD</key>
		<string> I and II
</string>
		<key>question</key>
		<string>361.Impediments to structural testing in even a moderate size program include which of the following? 
It is not possible to test each path 
It is not possible to test each choice point with the data that will show a fault 
 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>239</string>
		<key>identifier</key>
		<string>362</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only
 </string>
		<key>optionB</key>
		<string> I, II, and III
 </string>
		<key>optionC</key>
		<string> I and III only
 </string>
		<key>optionD</key>
		<string> II and III only
</string>
		<key>question</key>
		<string>362.In nonexecution-based testing of software, the inspections team includes which of the following roles? 
The moderator 
The client representative 
The recorder 
 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>240</string>
		<key>identifier</key>
		<string>363</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> need attention
 </string>
		<key>optionB</key>
		<string> to recode in order to decrease complexity
 </string>
		<key>optionC</key>
		<string> have more faults
 </string>
		<key>optionD</key>
		<string> should be tested by the SQA group  
</string>
		<key>question</key>
		<string>363.The primary use of complexity metrics is to determine which modules 
 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>241</string>
		<key>identifier</key>
		<string>364</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only
 </string>
		<key>optionB</key>
		<string> I, II, and III
 </string>
		<key>optionC</key>
		<string> I and III only
 </string>
		<key>optionD</key>
		<string> II andv III only 
</string>
		<key>question</key>
		<string>364.Which of the following statements is (are) true of testing techniques? 
All techniques have some advantages and disadvantages. 
All techniques are more or less equally effective at finding interface faults. 
All techniques are more or less equally cost-effective. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>242</string>
		<key>identifier</key>
		<string>365</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only
 </string>
		<key>optionB</key>
		<string> I and II only
 </string>
		<key>optionC</key>
		<string> III only
 </string>
		<key>optionD</key>
		<string> I, II, and III 
</string>
		<key>question</key>
		<string>365.Which of the following are advantages of bottom-up integration? 
It highlights design and coding faults early on. 
It helps isolate faults to the upper modules. 
It results in thorough testing of the operations models. 

  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>243</string>
		<key>identifier</key>
		<string>366</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III
 </string>
		<key>optionB</key>
		<string> II and III only
 </string>
		<key>optionC</key>
		<string> I and II only
 </string>
		<key>optionD</key>
		<string> II only  
</string>
		<key>question</key>
		<string>366.Utility of a software product includes which of the following? 
The ease with which a product can be used 
The usefulness of the product 
The cost-effectiveness of the product relative to competing products 
 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>244</string>
		<key>identifier</key>
		<string>367</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> To maintain different versions of the system
 </string>
		<key>optionB</key>
		<string> To keep management informed of the progress on various components of the product
 </string>
		<key>optionC</key>
		<string> To help integration testing be performed smoothly and quickly
 </string>
		<key>optionD</key>
		<string> To keep programmers from changing the same module(s) simultaneously  
</string>
		<key>question</key>
		<string>367.Baselines and access control systems are used for what purpose? 
 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>245</string>
		<key>identifier</key>
		<string>368</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II and III only
 </string>
		<key>optionB</key>
		<string> I, II, and III
 </string>
		<key>optionC</key>
		<string> I only
 </string>
		<key>optionD</key>
		<string> I and III only 
</string>
		<key>question</key>
		<string>368.Measures of reliability of a software product include which of the following? 
Mean time between failures 
Mean number of faults per thousand lines of code 
Mean time to repair 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>246</string>
		<key>identifier</key>
		<string>369</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
 </string>
		<key>optionB</key>
		<string> III only
 </string>
		<key>optionC</key>
		<string> I and II only
 </string>
		<key>optionD</key>
		<string> I, II, and III 
</string>
		<key>question</key>
		<string>369.Software engineering has which of the following objectives? 
Setting realistic expectations about the software development process 
Manipulating trade-offs in functionality, schedule, and budget 
Selecting hardware platforms for the software 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>247</string>
		<key>identifier</key>
		<string>370</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Scope
 </string>
		<key>optionB</key>
		<string> Robustness
 </string>
		<key>optionC</key>
		<string> Performance constraints
 </string>
		<key>optionD</key>
		<string> The user interface
</string>
		<key>question</key>
		<string>370.A common use of rapid prototyping is to help the client and the developer agree on which of the following aspects of the final product? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>248</string>
		<key>identifier</key>
		<string>371</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only
 </string>
		<key>optionB</key>
		<string> I, II, and III
 </string>
		<key>optionC</key>
		<string> II and III only
 </string>
		<key>optionD</key>
		<string> III only 
</string>
		<key>question</key>
		<string>371.Which of the following desirable characteristics does the incremental model have? 
The client does not have to wait for the complete product to get a return on investment. 
The model has an open modular architecture, which is relatively easy to maintain. 
New functionality is introduced gradually at the customer site. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>249</string>
		<key>identifier</key>
		<string>372</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It is a contract between the client and the developer.
 </string>
		<key>optionB</key>
		<string> It specifies the budget, milestones, and deliverables.
 </string>
		<key>optionC</key>
		<string> It is developed at the same time as the requirements document.
 </string>
		<key>optionD</key>
		<string> It is primarily developed by the developer's SQA group.
</string>
		<key>question</key>
		<string>372.Which of the following is true of a specification document for a software project? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>250</string>
		<key>identifier</key>
		<string>373</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It is purely action oriented.
 </string>
		<key>optionB</key>
		<string> It is both action and data oriented.
 </string>
		<key>optionC</key>
		<string> It is purely data oriented.
 </string>
		<key>optionD</key>
		<string> It is neither action nor data oriented
</string>
		<key>question</key>
		<string>373.Which of the following is true of Class Modeling in OOA? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>251</string>
		<key>identifier</key>
		<string>374</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only
 </string>
		<key>optionB</key>
		<string> I, II, and III
 </string>
		<key>optionC</key>
		<string> II and III only
 </string>
		<key>optionD</key>
		<string> I and II only 
</string>
		<key>question</key>
		<string>374.Which of the following are advantages of bottom-up integration? 
It highlights design and coding faults early on. 
It helps isolate faults to the upper modules. 
It results in thorough testing of the operations models. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>252</string>
		<key>identifier</key>
		<string>375</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only
 </string>
		<key>optionB</key>
		<string> I and II
 </string>
		<key>optionC</key>
		<string> none
 </string>
		<key>optionD</key>
		<string> I only
</string>
		<key>question</key>
		<string>375.Which of the following is (are) true about the technique known as all-definition-use path coverage? 
All paths between the definition of a variable and its use are tested. 
In practice, the number of paths is as large as the number of paths in simple path coverage. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>253</string>
		<key>identifier</key>
		<string>376</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I, II, and III
 </string>
		<key>optionB</key>
		<string> I only
 </string>
		<key>optionC</key>
		<string> II and III only
 </string>
		<key>optionD</key>
		<string> I and II only 
</string>
		<key>question</key>
		<string>376.Deliberate reuse is better than any other kind of reuse because components are likely to be which of the following? 
Better documented 
Better tested 
Easier to maintain 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>254</string>
		<key>identifier</key>
		<string>377</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and III only
 </string>
		<key>optionB</key>
		<string> I and II only
 </string>
		<key>optionC</key>
		<string> I, II, and III
 </string>
		<key>optionD</key>
		<string> II and III only  
</string>
		<key>question</key>
		<string>377.In nonexecution-based testing of software, the inspections team includes which of the following roles? 
The moderator 
The client representative 
The recorder 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>255</string>
		<key>identifier</key>
		<string>378</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> have more faults
 </string>
		<key>optionB</key>
		<string> to recode in order to decrease complexity
 </string>
		<key>optionC</key>
		<string> should be tested by the SQA group
 </string>
		<key>optionD</key>
		<string> need attention
</string>
		<key>question</key>
		<string>378.The primary use of complexity metrics is to determine which modules 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>256</string>
		<key>identifier</key>
		<string>379</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Branch coverage, path coverage, statement coverage
 </string>
		<key>optionB</key>
		<string> Statement coverage, branch coverage, path coverage
 </string>
		<key>optionC</key>
		<string> Path coverage, branch coverage, statement coverage
 </string>
		<key>optionD</key>
		<string> Branch coverage, statement coverage, pathcoverage 
</string>
		<key>question</key>
		<string>379.Which of the following ranks three structural testing techniques from weakest to strongest? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>257</string>
		<key>identifier</key>
		<string>380</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> Simultaneous implementation of multiple modules that are part of the same product
 </string>
		<key>optionB</key>
		<string> Collaborative software development across multiple organizations
 </string>
		<key>optionC</key>
		<string> Simultaneous implementation of multiple modules that are part of a different product
 </string>
		<key>optionD</key>
		<string> Software production by a team, either at the module level or at the code level 
</string>
		<key>question</key>
		<string>380.Programming-in-the-many refers to which of the following? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>258</string>
		<key>identifier</key>
		<string>381</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I and II only
 </string>
		<key>optionB</key>
		<string> I, II, and III
 </string>
		<key>optionC</key>
		<string> I only
 </string>
		<key>optionD</key>
		<string> II only 
</string>
		<key>question</key>
		<string>381.Product testing for contract software should include which of the following? 
Stress and volume testing 
Testing against specific constraints and requirements 
Documentation testing 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>259</string>
		<key>identifier</key>
		<string>382</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> three steps: preparation, inspection, rework
 </string>
		<key>optionB</key>
		<string> a flexible number of steps, depending on the quality of the document
 </string>
		<key>optionC</key>
		<string> four steps: preparation, inspection, rework, follow-up
 </string>
		<key>optionD</key>
		<string> five steps: overview, preparation, inspection, rework, follow-up
</string>
		<key>question</key>
		<string>382.In nonexecution-based testing of software, code inspection is a formal process that consists of 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>260</string>
		<key>identifier</key>
		<string>383</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
 </string>
		<key>optionB</key>
		<string> II and III only
 </string>
		<key>optionC</key>
		<string> I and II only
 </string>
		<key>optionD</key>
		<string> I, II, and III  
</string>
		<key>question</key>
		<string>383.Which of the following are advantages of sandwich integration? 
Fault isolation is present at all times. 
Design faults in the logic modules are identified early on. 
Operations modules are fully debugged. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>261</string>
		<key>identifier</key>
		<string>384</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The called module checks input to ensure that it has been called with inappropriate input.
 </string>
		<key>optionB</key>
		<string> Assertions are placed in the called module.
 </string>
		<key>optionC</key>
		<string> The calling module checks input to the called module to ensure that the input is appropriate.
 </string>
		<key>optionD</key>
		<string> Both calling and called modules check for the appropriateness of an input to the called module.  
</string>
		<key>question</key>
		<string>384.Which of the following is true about defensive programming? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>262</string>
		<key>identifier</key>
		<string>385</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> to keep track of different variations of component modules in a software product
 </string>
		<key>optionB</key>
		<string> specify which versions and which variations of each component are required for a complete product
 </string>
		<key>optionC</key>
		<string> maintain the documentation that specifies which variations and versions go into a complete product
 </string>
		<key>optionD</key>
		<string> keep track of different versions of component modules in a software product  
</string>
		<key>question</key>
		<string>385.A configuration-control tool is used to 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>b</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>263</string>
		<key>identifier</key>
		<string>386</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> II only
 </string>
		<key>optionB</key>
		<string> I and II
 </string>
		<key>optionC</key>
		<string> none
 </string>
		<key>optionD</key>
		<string> I only
</string>
		<key>question</key>
		<string>386.Impediments to structural testing in even a moderate size program include which of the following? 
It is not possible to test each path 
It is not possible to test each choice point with the data that will show a fault 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>a</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>264</string>
		<key>identifier</key>
		<string>387</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> provides tools having the same visual appearance and functional interface
 </string>
		<key>optionB</key>
		<string> supports a specific software process through a uniform user interface
 </string>
		<key>optionC</key>
		<string> supports recording of discussions between users of a product
 </string>
		<key>optionD</key>
		<string> permits several users to communicate with each other rapidly
</string>
		<key>question</key>
		<string>387.User interface integration usually refers to an environment that 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>265</string>
		<key>identifier</key>
		<string>388</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only
 </string>
		<key>optionB</key>
		<string> I, II, and III
 </string>
		<key>optionC</key>
		<string> I and III only
 </string>
		<key>optionD</key>
		<string> I and II only 
</string>
		<key>question</key>
		<string>388.Which of the following are advantages of top-down integration testing of software? 
It helps isolate faults to lower modules as they are added. 
It helps debug lower-level modules faster. 
It helps identify design faults earlier in the process. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>266</string>
		<key>identifier</key>
		<string>389</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> The ideal order depends on the software product.
 </string>
		<key>optionB</key>
		<string> Module testing should be completed before integration testing.
 </string>
		<key>optionC</key>
		<string> Integration testing should be completed before module testing.
 </string>
		<key>optionD</key>
		<string> They should be done together. 
</string>
		<key>question</key>
		<string>389.The ideal order for module testing and integration testing is given by which of the following? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>267</string>
		<key>identifier</key>
		<string>390</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> III only
 </string>
		<key>optionB</key>
		<string> I, II, and III
 </string>
		<key>optionC</key>
		<string> I only
 </string>
		<key>optionD</key>
		<string> I and II only
</string>
		<key>question</key>
		<string>390.Which of the following belong in the specification document for a software project? 
Expected input and corresponding output of the system 
Explicit constraints the system must satisfy 
Explicit milestones and a general description of deliverables for the system 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>268</string>
		<key>identifier</key>
		<string>391</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> acceptance testing, installation testing
 </string>
		<key>optionB</key>
		<string> robustness testing, integration testing
 </string>
		<key>optionC</key>
		<string> robustness testing, installation testing
 </string>
		<key>optionD</key>
		<string> acceptance testing, integration testing  
</string>
		<key>question</key>
		<string>391.In software development, product testing includes performance testing, _____, _____, and documentation testing. 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>269</string>
		<key>identifier</key>
		<string>392</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
 </string>
		<key>optionB</key>
		<string> III only
 </string>
		<key>optionC</key>
		<string> I, II, and III
 </string>
		<key>optionD</key>
		<string> I and II only  
</string>
		<key>question</key>
		<string>392.In choosing a language for the final product, which of the following factors should be considered? 
The client's experience with, and tools for, the language 
The language's suitability for the application 
The costs, benefits, and risks of using the language 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>270</string>
		<key>identifier</key>
		<string>393</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> It does not contribute at all.
 </string>
		<key>optionB</key>
		<string> It is essential.
 </string>
		<key>optionC</key>
		<string> It contributes relatively little.
 </string>
		<key>optionD</key>
		<string> It should be the starting point for all other considerations. 
</string>
		<key>question</key>
		<string>393.Of the following, which best characterizes the role of hardware considerations in the development of high-quality software for a typical project? 
  </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>c</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>271</string>
		<key>identifier</key>
		<string>394</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> I only
 </string>
		<key>optionB</key>
		<string> I and III only
 </string>
		<key>optionC</key>
		<string> I, II, and III
 </string>
		<key>optionD</key>
		<string> I and II only  
</string>
		<key>question</key>
		<string>394.The input-output specifications should cover which of the following kinds of input? 
Complete and correct input 
Error-ridden input 
Incomplete input 
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
	<dict>
		<key>answer</key>
		<string>d</string>
		<key>done</key>
		<string>0</string>
		<key>id</key>
		<string>272</string>
		<key>identifier</key>
		<string>395</string>
		<key>mark</key>
		<string>0</string>
		<key>optionA</key>
		<string> control flow diagrams
 </string>
		<key>optionB</key>
		<string> data flow diagrams
 </string>
		<key>optionC</key>
		<string> acceptance criteria
 </string>
		<key>optionD</key>
		<string> input-output specifications 
</string>
		<key>question</key>
		<string>395.The _____ define which input a software product must accept and what the corresponding output must be.  
 </string>
		<key>wrong</key>
		<string>0</string>
	</dict>
</array>
</plist>
